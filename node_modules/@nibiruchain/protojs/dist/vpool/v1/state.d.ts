import Long from "long";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "nibiru.vpool.v1";
export declare enum Direction {
    DIRECTION_UNSPECIFIED = 0,
    ADD_TO_POOL = 1,
    REMOVE_FROM_POOL = 2,
    UNRECOGNIZED = -1
}
export declare function directionFromJSON(object: any): Direction;
export declare function directionToJSON(object: Direction): string;
/** Enumerates different options of calculating twap. */
export declare enum TwapCalcOption {
    TWAP_CALC_OPTION_UNSPECIFIED = 0,
    /** SPOT - Spot price from quote asset reserve / base asset reserve */
    SPOT = 1,
    /** QUOTE_ASSET_SWAP - Swapping with quote assets, output denominated in base assets */
    QUOTE_ASSET_SWAP = 2,
    /** BASE_ASSET_SWAP - Swapping with base assets, output denominated in quote assets */
    BASE_ASSET_SWAP = 3,
    UNRECOGNIZED = -1
}
export declare function twapCalcOptionFromJSON(object: any): TwapCalcOption;
export declare function twapCalcOptionToJSON(object: TwapCalcOption): string;
/**
 * A virtual pool used only for price discovery of perpetual futures contracts.
 * No real liquidity exists in this pool.
 */
export interface Vpool {
    /** always BASE:QUOTE, e.g. BTC:NUSD or ETH:NUSD */
    pair: string;
    /** base asset is the crypto asset, e.g. BTC or ETH */
    baseAssetReserve: string;
    /** quote asset is usually stablecoin, in our case NUSD */
    quoteAssetReserve: string;
    config?: VpoolConfig;
}
export interface VpoolConfig {
    /** ratio applied to reserves in order not to over trade */
    tradeLimitRatio: string;
    /** percentage that a single open or close position can alter the reserve amounts */
    fluctuationLimitRatio: string;
    /** max_oracle_spread_ratio */
    maxOracleSpreadRatio: string;
    /** maintenance_margin_ratio */
    maintenanceMarginRatio: string;
    /** max_leverage */
    maxLeverage: string;
}
/** CurrentTWAP states defines the numerator and denominator for the TWAP calculation */
export interface CurrentTWAP {
    pairId: string;
    numerator: string;
    denominator: string;
    price: string;
}
/** a snapshot of the vpool's reserves at a given point in time */
export interface ReserveSnapshot {
    pair: string;
    baseAssetReserve: string;
    /** quote asset is usually the margin asset, e.g. NUSD */
    quoteAssetReserve: string;
    /** milliseconds since unix epoch */
    timestampMs: Long;
}
/**
 * PoolPrices is a simple structure that displays a snapshot of the mark and index
 * prices for an asset. Empty strings for the indexPrice or twapMark fields
 * indicate that the price is currently unavailable.
 */
export interface PoolPrices {
    /** Pair identifier for the two assets. Always in format 'base:quote' */
    pair: string;
    /**
     * MarkPrice is the instantaneous price of the perp.
     * Equivalent to quoteAssetReserve / baseAssetReserve.
     */
    markPrice: string;
    /** IndexPrice is the price of the "underlying" for the perp */
    indexPrice: string;
    /** TwapMark is the time-weighted average (mark) price. */
    twapMark: string;
    /** SwapInvariant is the product of the reserves, commonly referred to as "k". */
    swapInvariant: string;
    /** The block number corresponding to each price */
    blockNumber: Long;
}
export declare const Vpool: {
    encode(message: Vpool, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Vpool;
    fromJSON(object: any): Vpool;
    toJSON(message: Vpool): unknown;
    fromPartial<I extends {
        pair?: string | undefined;
        baseAssetReserve?: string | undefined;
        quoteAssetReserve?: string | undefined;
        config?: {
            tradeLimitRatio?: string | undefined;
            fluctuationLimitRatio?: string | undefined;
            maxOracleSpreadRatio?: string | undefined;
            maintenanceMarginRatio?: string | undefined;
            maxLeverage?: string | undefined;
        } | undefined;
    } & {
        pair?: string | undefined;
        baseAssetReserve?: string | undefined;
        quoteAssetReserve?: string | undefined;
        config?: ({
            tradeLimitRatio?: string | undefined;
            fluctuationLimitRatio?: string | undefined;
            maxOracleSpreadRatio?: string | undefined;
            maintenanceMarginRatio?: string | undefined;
            maxLeverage?: string | undefined;
        } & {
            tradeLimitRatio?: string | undefined;
            fluctuationLimitRatio?: string | undefined;
            maxOracleSpreadRatio?: string | undefined;
            maintenanceMarginRatio?: string | undefined;
            maxLeverage?: string | undefined;
        } & Record<Exclude<keyof I["config"], keyof VpoolConfig>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof Vpool>, never>>(object: I): Vpool;
};
export declare const VpoolConfig: {
    encode(message: VpoolConfig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): VpoolConfig;
    fromJSON(object: any): VpoolConfig;
    toJSON(message: VpoolConfig): unknown;
    fromPartial<I extends {
        tradeLimitRatio?: string | undefined;
        fluctuationLimitRatio?: string | undefined;
        maxOracleSpreadRatio?: string | undefined;
        maintenanceMarginRatio?: string | undefined;
        maxLeverage?: string | undefined;
    } & {
        tradeLimitRatio?: string | undefined;
        fluctuationLimitRatio?: string | undefined;
        maxOracleSpreadRatio?: string | undefined;
        maintenanceMarginRatio?: string | undefined;
        maxLeverage?: string | undefined;
    } & Record<Exclude<keyof I, keyof VpoolConfig>, never>>(object: I): VpoolConfig;
};
export declare const CurrentTWAP: {
    encode(message: CurrentTWAP, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CurrentTWAP;
    fromJSON(object: any): CurrentTWAP;
    toJSON(message: CurrentTWAP): unknown;
    fromPartial<I extends {
        pairId?: string | undefined;
        numerator?: string | undefined;
        denominator?: string | undefined;
        price?: string | undefined;
    } & {
        pairId?: string | undefined;
        numerator?: string | undefined;
        denominator?: string | undefined;
        price?: string | undefined;
    } & Record<Exclude<keyof I, keyof CurrentTWAP>, never>>(object: I): CurrentTWAP;
};
export declare const ReserveSnapshot: {
    encode(message: ReserveSnapshot, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ReserveSnapshot;
    fromJSON(object: any): ReserveSnapshot;
    toJSON(message: ReserveSnapshot): unknown;
    fromPartial<I extends {
        pair?: string | undefined;
        baseAssetReserve?: string | undefined;
        quoteAssetReserve?: string | undefined;
        timestampMs?: string | number | Long.Long | undefined;
    } & {
        pair?: string | undefined;
        baseAssetReserve?: string | undefined;
        quoteAssetReserve?: string | undefined;
        timestampMs?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["timestampMs"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof ReserveSnapshot>, never>>(object: I): ReserveSnapshot;
};
export declare const PoolPrices: {
    encode(message: PoolPrices, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PoolPrices;
    fromJSON(object: any): PoolPrices;
    toJSON(message: PoolPrices): unknown;
    fromPartial<I extends {
        pair?: string | undefined;
        markPrice?: string | undefined;
        indexPrice?: string | undefined;
        twapMark?: string | undefined;
        swapInvariant?: string | undefined;
        blockNumber?: string | number | Long.Long | undefined;
    } & {
        pair?: string | undefined;
        markPrice?: string | undefined;
        indexPrice?: string | undefined;
        twapMark?: string | undefined;
        swapInvariant?: string | undefined;
        blockNumber?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockNumber"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof PoolPrices>, never>>(object: I): PoolPrices;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
declare type KeysOfUnion<T> = T extends T ? keyof T : never;
export declare type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
//# sourceMappingURL=state.d.ts.map