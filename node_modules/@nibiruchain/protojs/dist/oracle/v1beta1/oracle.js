"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PairReward = exports.ExchangeRateTuple = exports.AggregateExchangeRateVote = exports.AggregateExchangeRatePrevote = exports.Params = exports.protobufPackage = void 0;
/* eslint-disable */
const duration_1 = require("../../google/protobuf/duration");
const long_1 = __importDefault(require("long"));
const coin_1 = require("../../cosmos/base/v1beta1/coin");
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = "nibiru.oracle.v1beta1";
function createBaseParams() {
    return {
        votePeriod: long_1.default.UZERO,
        voteThreshold: "",
        rewardBand: "",
        whitelist: [],
        slashFraction: "",
        slashWindow: long_1.default.UZERO,
        minValidPerWindow: "",
        twapLookbackWindow: undefined,
        minVoters: long_1.default.UZERO,
    };
}
exports.Params = {
    encode(message, writer = _m0.Writer.create()) {
        if (!message.votePeriod.isZero()) {
            writer.uint32(8).uint64(message.votePeriod);
        }
        if (message.voteThreshold !== "") {
            writer.uint32(18).string(message.voteThreshold);
        }
        if (message.rewardBand !== "") {
            writer.uint32(26).string(message.rewardBand);
        }
        for (const v of message.whitelist) {
            writer.uint32(34).string(v);
        }
        if (message.slashFraction !== "") {
            writer.uint32(42).string(message.slashFraction);
        }
        if (!message.slashWindow.isZero()) {
            writer.uint32(48).uint64(message.slashWindow);
        }
        if (message.minValidPerWindow !== "") {
            writer.uint32(58).string(message.minValidPerWindow);
        }
        if (message.twapLookbackWindow !== undefined) {
            duration_1.Duration.encode(message.twapLookbackWindow, writer.uint32(66).fork()).ldelim();
        }
        if (!message.minVoters.isZero()) {
            writer.uint32(72).uint64(message.minVoters);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.votePeriod = reader.uint64();
                    break;
                case 2:
                    message.voteThreshold = reader.string();
                    break;
                case 3:
                    message.rewardBand = reader.string();
                    break;
                case 4:
                    message.whitelist.push(reader.string());
                    break;
                case 5:
                    message.slashFraction = reader.string();
                    break;
                case 6:
                    message.slashWindow = reader.uint64();
                    break;
                case 7:
                    message.minValidPerWindow = reader.string();
                    break;
                case 8:
                    message.twapLookbackWindow = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.minVoters = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            votePeriod: isSet(object.votePeriod)
                ? long_1.default.fromValue(object.votePeriod)
                : long_1.default.UZERO,
            voteThreshold: isSet(object.voteThreshold) ? String(object.voteThreshold) : "",
            rewardBand: isSet(object.rewardBand) ? String(object.rewardBand) : "",
            whitelist: Array.isArray(object === null || object === void 0 ? void 0 : object.whitelist)
                ? object.whitelist.map((e) => String(e))
                : [],
            slashFraction: isSet(object.slashFraction) ? String(object.slashFraction) : "",
            slashWindow: isSet(object.slashWindow)
                ? long_1.default.fromValue(object.slashWindow)
                : long_1.default.UZERO,
            minValidPerWindow: isSet(object.minValidPerWindow)
                ? String(object.minValidPerWindow)
                : "",
            twapLookbackWindow: isSet(object.twapLookbackWindow)
                ? duration_1.Duration.fromJSON(object.twapLookbackWindow)
                : undefined,
            minVoters: isSet(object.minVoters)
                ? long_1.default.fromValue(object.minVoters)
                : long_1.default.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.votePeriod !== undefined &&
            (obj.votePeriod = (message.votePeriod || long_1.default.UZERO).toString());
        message.voteThreshold !== undefined && (obj.voteThreshold = message.voteThreshold);
        message.rewardBand !== undefined && (obj.rewardBand = message.rewardBand);
        if (message.whitelist) {
            obj.whitelist = message.whitelist.map((e) => e);
        }
        else {
            obj.whitelist = [];
        }
        message.slashFraction !== undefined && (obj.slashFraction = message.slashFraction);
        message.slashWindow !== undefined &&
            (obj.slashWindow = (message.slashWindow || long_1.default.UZERO).toString());
        message.minValidPerWindow !== undefined &&
            (obj.minValidPerWindow = message.minValidPerWindow);
        message.twapLookbackWindow !== undefined &&
            (obj.twapLookbackWindow = message.twapLookbackWindow
                ? duration_1.Duration.toJSON(message.twapLookbackWindow)
                : undefined);
        message.minVoters !== undefined &&
            (obj.minVoters = (message.minVoters || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseParams();
        message.votePeriod =
            object.votePeriod !== undefined && object.votePeriod !== null
                ? long_1.default.fromValue(object.votePeriod)
                : long_1.default.UZERO;
        message.voteThreshold = (_a = object.voteThreshold) !== null && _a !== void 0 ? _a : "";
        message.rewardBand = (_b = object.rewardBand) !== null && _b !== void 0 ? _b : "";
        message.whitelist = ((_c = object.whitelist) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.slashFraction = (_d = object.slashFraction) !== null && _d !== void 0 ? _d : "";
        message.slashWindow =
            object.slashWindow !== undefined && object.slashWindow !== null
                ? long_1.default.fromValue(object.slashWindow)
                : long_1.default.UZERO;
        message.minValidPerWindow = (_e = object.minValidPerWindow) !== null && _e !== void 0 ? _e : "";
        message.twapLookbackWindow =
            object.twapLookbackWindow !== undefined && object.twapLookbackWindow !== null
                ? duration_1.Duration.fromPartial(object.twapLookbackWindow)
                : undefined;
        message.minVoters =
            object.minVoters !== undefined && object.minVoters !== null
                ? long_1.default.fromValue(object.minVoters)
                : long_1.default.UZERO;
        return message;
    },
};
function createBaseAggregateExchangeRatePrevote() {
    return { hash: "", voter: "", submitBlock: long_1.default.UZERO };
}
exports.AggregateExchangeRatePrevote = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.hash !== "") {
            writer.uint32(10).string(message.hash);
        }
        if (message.voter !== "") {
            writer.uint32(18).string(message.voter);
        }
        if (!message.submitBlock.isZero()) {
            writer.uint32(24).uint64(message.submitBlock);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAggregateExchangeRatePrevote();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hash = reader.string();
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                case 3:
                    message.submitBlock = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            hash: isSet(object.hash) ? String(object.hash) : "",
            voter: isSet(object.voter) ? String(object.voter) : "",
            submitBlock: isSet(object.submitBlock)
                ? long_1.default.fromValue(object.submitBlock)
                : long_1.default.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.hash !== undefined && (obj.hash = message.hash);
        message.voter !== undefined && (obj.voter = message.voter);
        message.submitBlock !== undefined &&
            (obj.submitBlock = (message.submitBlock || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseAggregateExchangeRatePrevote();
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : "";
        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : "";
        message.submitBlock =
            object.submitBlock !== undefined && object.submitBlock !== null
                ? long_1.default.fromValue(object.submitBlock)
                : long_1.default.UZERO;
        return message;
    },
};
function createBaseAggregateExchangeRateVote() {
    return { exchangeRateTuples: [], voter: "" };
}
exports.AggregateExchangeRateVote = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.exchangeRateTuples) {
            exports.ExchangeRateTuple.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.voter !== "") {
            writer.uint32(18).string(message.voter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAggregateExchangeRateVote();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exchangeRateTuples.push(exports.ExchangeRateTuple.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.voter = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            exchangeRateTuples: Array.isArray(object === null || object === void 0 ? void 0 : object.exchangeRateTuples)
                ? object.exchangeRateTuples.map((e) => exports.ExchangeRateTuple.fromJSON(e))
                : [],
            voter: isSet(object.voter) ? String(object.voter) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.exchangeRateTuples) {
            obj.exchangeRateTuples = message.exchangeRateTuples.map((e) => e ? exports.ExchangeRateTuple.toJSON(e) : undefined);
        }
        else {
            obj.exchangeRateTuples = [];
        }
        message.voter !== undefined && (obj.voter = message.voter);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseAggregateExchangeRateVote();
        message.exchangeRateTuples =
            ((_a = object.exchangeRateTuples) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ExchangeRateTuple.fromPartial(e))) || [];
        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseExchangeRateTuple() {
    return { pair: "", exchangeRate: "" };
}
exports.ExchangeRateTuple = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.exchangeRate !== "") {
            writer.uint32(18).string(message.exchangeRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExchangeRateTuple();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.exchangeRate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            exchangeRate: isSet(object.exchangeRate) ? String(object.exchangeRate) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.exchangeRate !== undefined && (obj.exchangeRate = message.exchangeRate);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseExchangeRateTuple();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.exchangeRate = (_b = object.exchangeRate) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBasePairReward() {
    return { pair: "", id: long_1.default.UZERO, votePeriods: long_1.default.UZERO, coins: [] };
}
exports.PairReward = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (!message.id.isZero()) {
            writer.uint32(16).uint64(message.id);
        }
        if (!message.votePeriods.isZero()) {
            writer.uint32(24).uint64(message.votePeriods);
        }
        for (const v of message.coins) {
            coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePairReward();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.id = reader.uint64();
                    break;
                case 3:
                    message.votePeriods = reader.uint64();
                    break;
                case 4:
                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            id: isSet(object.id) ? long_1.default.fromValue(object.id) : long_1.default.UZERO,
            votePeriods: isSet(object.votePeriods)
                ? long_1.default.fromValue(object.votePeriods)
                : long_1.default.UZERO,
            coins: Array.isArray(object === null || object === void 0 ? void 0 : object.coins)
                ? object.coins.map((e) => coin_1.Coin.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.id !== undefined && (obj.id = (message.id || long_1.default.UZERO).toString());
        message.votePeriods !== undefined &&
            (obj.votePeriods = (message.votePeriods || long_1.default.UZERO).toString());
        if (message.coins) {
            obj.coins = message.coins.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));
        }
        else {
            obj.coins = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePairReward();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.id =
            object.id !== undefined && object.id !== null
                ? long_1.default.fromValue(object.id)
                : long_1.default.UZERO;
        message.votePeriods =
            object.votePeriods !== undefined && object.votePeriods !== null
                ? long_1.default.fromValue(object.votePeriods)
                : long_1.default.UZERO;
        message.coins = ((_b = object.coins) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
    },
};
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=oracle.js.map