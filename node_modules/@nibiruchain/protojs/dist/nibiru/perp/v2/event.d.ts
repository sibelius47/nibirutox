import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { AMM, Market, Position } from "./state";
export declare const protobufPackage = "nibiru.perp.v2";
/** Emitted when a position changes. */
export interface PositionChangedEvent {
    finalPosition?: Position;
    /**
     * Position notional (in quote units) after the change. In general,
     * 'notional = baseAmount * priceQuotePerBase', where size is the baseAmount.
     */
    positionNotional: string;
    /** Transaction fee paid. A "taker" fee. */
    transactionFee?: Coin;
    /** realize profits and losses after the change */
    realizedPnl: string;
    /**
     * Amount of bad debt cleared by the PerpEF during the change.
     * Bad debt is negative net margin past the liquidation point of a position.
     */
    badDebt?: Coin;
    /**
     * A funding payment made or received by the trader on the current position.
     * 'fundingPayment' is positive if 'owner' is the sender and negative if 'owner'
     * is the receiver of the payment. Its magnitude is abs(size * fundingRate).
     * Funding payments act to converge the mark price and index price
     * (average price on major exchanges).
     */
    fundingPayment: string;
    /** The block number at which this position was changed. */
    blockHeight: Long;
    /**
     * margin_to_user is the amount of collateral received by the trader during
     * the position change. A positve value indicates that the trader received
     * funds, while a negative value indicates that the trader spent funds.
     */
    marginToUser: string;
    /**
     * change_reason describes the reason for why the position resulted in a
     * change. Change type can take the following values:
     *
     * - CHANGE_REASON_UNSPECIFIED: Unspecified change reason.
     * - CHANGE_REASON_ADD_MARGIN: Margin was added to the position.
     * - CHANGE_REASON_REMOVE_MARGIN: Margin was removed from the position.
     * - CHANGE_REASON_OPEN_POSITION: A new position was opened.
     * - CHANGE_REASON_CLOSE_POSITION: An existing position was closed.
     */
    changeReason: string;
}
/**
 * Emitted when a position is liquidated. Wraps a PositionChanged event since a
 * liquidation causes position changes.
 */
export interface PositionLiquidatedEvent {
    positionChangedEvent?: PositionChangedEvent;
    /** Address of the account that executed the tx. */
    liquidatorAddress: string;
    /** Commission (in margin units) received by 'liquidator'. */
    feeToLiquidator?: Coin;
    /** Commission (in margin units) given to the ecosystem fund. */
    feeToEcosystemFund?: Coin;
}
/** Emitted when a position is settled. */
export interface PositionSettledEvent {
    /** Identifier for the virtual pool of the position. */
    pair: string;
    /** Owner of the position. */
    traderAddress: string;
    /** Settled coin as dictated by the settlement price of the perp.amm. */
    settledCoins: Coin[];
}
/** Emitted when the funding rate changes for a market. */
export interface FundingRateChangedEvent {
    /** The pair for which the funding rate was calculated. */
    pair: string;
    /** The mark price of the pair. */
    markPriceTwap: string;
    /** The oracle index price of the pair. */
    indexPriceTwap: string;
    /** The latest premium fraction just calculated. */
    premiumFraction: string;
    /**
     * The market's latest cumulative premium fraction.
     * The funding payment a position will pay is the difference between this
     * value and the latest cumulative premium fraction on the position,
     * multiplied by the position size.
     */
    cumulativePremiumFraction: string;
}
/** Emitted when liquidation fails. */
export interface LiquidationFailedEvent {
    /** The pair for which we are trying to liquidate. */
    pair: string;
    /** owner of the position. */
    trader: string;
    /** Address of the account that executed the tx. */
    liquidator: string;
    /** Reason for the liquidation failure. */
    reason: LiquidationFailedEvent_LiquidationFailedReason;
}
export declare enum LiquidationFailedEvent_LiquidationFailedReason {
    UNSPECIFIED = 0,
    /** POSITION_HEALTHY - the position is healthy and does not need to be liquidated. */
    POSITION_HEALTHY = 1,
    /** NONEXISTENT_PAIR - the pair does not exist. */
    NONEXISTENT_PAIR = 2,
    /** NONEXISTENT_POSITION - the position does not exist. */
    NONEXISTENT_POSITION = 3,
    UNRECOGNIZED = -1
}
export declare function liquidationFailedEvent_LiquidationFailedReasonFromJSON(object: any): LiquidationFailedEvent_LiquidationFailedReason;
export declare function liquidationFailedEvent_LiquidationFailedReasonToJSON(object: LiquidationFailedEvent_LiquidationFailedReason): string;
/**
 * This event is emitted when the amm is updated, which can be triggered by
 * the following events:
 *
 * - swap
 * - edit price multiplier
 * - edit depth
 */
export interface AmmUpdatedEvent {
    /** the final state of the AMM */
    finalAmm?: AMM;
    /** The mark price of the pair. */
    markPriceTwap: string;
    /** The oracle index price of the pair. */
    indexPriceTwap: string;
}
/**
 * This event is emitted at the end of every block for persisting market changes
 * off-chain
 *
 * Market changes are triggered by the following actions:
 *
 * - disabling market
 * - changing market fees
 * - bad debt is prepaid by the ecosystem fund
 */
export interface MarketUpdatedEvent {
    /** the final state of the market */
    finalMarket?: Market;
}
export declare const PositionChangedEvent: {
    encode(message: PositionChangedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PositionChangedEvent;
    fromJSON(object: any): PositionChangedEvent;
    toJSON(message: PositionChangedEvent): unknown;
    create<I extends {
        finalPosition?: {
            traderAddress?: string | undefined;
            pair?: string | undefined;
            size?: string | undefined;
            margin?: string | undefined;
            openNotional?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
        } | undefined;
        positionNotional?: string | undefined;
        transactionFee?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        realizedPnl?: string | undefined;
        badDebt?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        fundingPayment?: string | undefined;
        blockHeight?: string | number | Long.Long | undefined;
        marginToUser?: string | undefined;
        changeReason?: string | undefined;
    } & {
        finalPosition?: ({
            traderAddress?: string | undefined;
            pair?: string | undefined;
            size?: string | undefined;
            margin?: string | undefined;
            openNotional?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
        } & {
            traderAddress?: string | undefined;
            pair?: string | undefined;
            size?: string | undefined;
            margin?: string | undefined;
            openNotional?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            lastUpdatedBlockNumber?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & { [K in Exclude<keyof I["finalPosition"]["lastUpdatedBlockNumber"], keyof Long.Long>]: never; }) | undefined;
        } & { [K_1 in Exclude<keyof I["finalPosition"], keyof Position>]: never; }) | undefined;
        positionNotional?: string | undefined;
        transactionFee?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_2 in Exclude<keyof I["transactionFee"], keyof Coin>]: never; }) | undefined;
        realizedPnl?: string | undefined;
        badDebt?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_3 in Exclude<keyof I["badDebt"], keyof Coin>]: never; }) | undefined;
        fundingPayment?: string | undefined;
        blockHeight?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & { [K_4 in Exclude<keyof I["blockHeight"], keyof Long.Long>]: never; }) | undefined;
        marginToUser?: string | undefined;
        changeReason?: string | undefined;
    } & { [K_5 in Exclude<keyof I, keyof PositionChangedEvent>]: never; }>(base?: I | undefined): PositionChangedEvent;
    fromPartial<I_1 extends {
        finalPosition?: {
            traderAddress?: string | undefined;
            pair?: string | undefined;
            size?: string | undefined;
            margin?: string | undefined;
            openNotional?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
        } | undefined;
        positionNotional?: string | undefined;
        transactionFee?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        realizedPnl?: string | undefined;
        badDebt?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        fundingPayment?: string | undefined;
        blockHeight?: string | number | Long.Long | undefined;
        marginToUser?: string | undefined;
        changeReason?: string | undefined;
    } & {
        finalPosition?: ({
            traderAddress?: string | undefined;
            pair?: string | undefined;
            size?: string | undefined;
            margin?: string | undefined;
            openNotional?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
        } & {
            traderAddress?: string | undefined;
            pair?: string | undefined;
            size?: string | undefined;
            margin?: string | undefined;
            openNotional?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            lastUpdatedBlockNumber?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & { [K_6 in Exclude<keyof I_1["finalPosition"]["lastUpdatedBlockNumber"], keyof Long.Long>]: never; }) | undefined;
        } & { [K_7 in Exclude<keyof I_1["finalPosition"], keyof Position>]: never; }) | undefined;
        positionNotional?: string | undefined;
        transactionFee?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_8 in Exclude<keyof I_1["transactionFee"], keyof Coin>]: never; }) | undefined;
        realizedPnl?: string | undefined;
        badDebt?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_9 in Exclude<keyof I_1["badDebt"], keyof Coin>]: never; }) | undefined;
        fundingPayment?: string | undefined;
        blockHeight?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & { [K_10 in Exclude<keyof I_1["blockHeight"], keyof Long.Long>]: never; }) | undefined;
        marginToUser?: string | undefined;
        changeReason?: string | undefined;
    } & { [K_11 in Exclude<keyof I_1, keyof PositionChangedEvent>]: never; }>(object: I_1): PositionChangedEvent;
};
export declare const PositionLiquidatedEvent: {
    encode(message: PositionLiquidatedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PositionLiquidatedEvent;
    fromJSON(object: any): PositionLiquidatedEvent;
    toJSON(message: PositionLiquidatedEvent): unknown;
    create<I extends {
        positionChangedEvent?: {
            finalPosition?: {
                traderAddress?: string | undefined;
                pair?: string | undefined;
                size?: string | undefined;
                margin?: string | undefined;
                openNotional?: string | undefined;
                latestCumulativePremiumFraction?: string | undefined;
                lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
            } | undefined;
            positionNotional?: string | undefined;
            transactionFee?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
            realizedPnl?: string | undefined;
            badDebt?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
            fundingPayment?: string | undefined;
            blockHeight?: string | number | Long.Long | undefined;
            marginToUser?: string | undefined;
            changeReason?: string | undefined;
        } | undefined;
        liquidatorAddress?: string | undefined;
        feeToLiquidator?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        feeToEcosystemFund?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
    } & {
        positionChangedEvent?: ({
            finalPosition?: {
                traderAddress?: string | undefined;
                pair?: string | undefined;
                size?: string | undefined;
                margin?: string | undefined;
                openNotional?: string | undefined;
                latestCumulativePremiumFraction?: string | undefined;
                lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
            } | undefined;
            positionNotional?: string | undefined;
            transactionFee?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
            realizedPnl?: string | undefined;
            badDebt?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
            fundingPayment?: string | undefined;
            blockHeight?: string | number | Long.Long | undefined;
            marginToUser?: string | undefined;
            changeReason?: string | undefined;
        } & {
            finalPosition?: ({
                traderAddress?: string | undefined;
                pair?: string | undefined;
                size?: string | undefined;
                margin?: string | undefined;
                openNotional?: string | undefined;
                latestCumulativePremiumFraction?: string | undefined;
                lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
            } & {
                traderAddress?: string | undefined;
                pair?: string | undefined;
                size?: string | undefined;
                margin?: string | undefined;
                openNotional?: string | undefined;
                latestCumulativePremiumFraction?: string | undefined;
                lastUpdatedBlockNumber?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & { [K in Exclude<keyof I["positionChangedEvent"]["finalPosition"]["lastUpdatedBlockNumber"], keyof Long.Long>]: never; }) | undefined;
            } & { [K_1 in Exclude<keyof I["positionChangedEvent"]["finalPosition"], keyof Position>]: never; }) | undefined;
            positionNotional?: string | undefined;
            transactionFee?: ({
                denom?: string | undefined;
                amount?: string | undefined;
            } & {
                denom?: string | undefined;
                amount?: string | undefined;
            } & { [K_2 in Exclude<keyof I["positionChangedEvent"]["transactionFee"], keyof Coin>]: never; }) | undefined;
            realizedPnl?: string | undefined;
            badDebt?: ({
                denom?: string | undefined;
                amount?: string | undefined;
            } & {
                denom?: string | undefined;
                amount?: string | undefined;
            } & { [K_3 in Exclude<keyof I["positionChangedEvent"]["badDebt"], keyof Coin>]: never; }) | undefined;
            fundingPayment?: string | undefined;
            blockHeight?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & { [K_4 in Exclude<keyof I["positionChangedEvent"]["blockHeight"], keyof Long.Long>]: never; }) | undefined;
            marginToUser?: string | undefined;
            changeReason?: string | undefined;
        } & { [K_5 in Exclude<keyof I["positionChangedEvent"], keyof PositionChangedEvent>]: never; }) | undefined;
        liquidatorAddress?: string | undefined;
        feeToLiquidator?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_6 in Exclude<keyof I["feeToLiquidator"], keyof Coin>]: never; }) | undefined;
        feeToEcosystemFund?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_7 in Exclude<keyof I["feeToEcosystemFund"], keyof Coin>]: never; }) | undefined;
    } & { [K_8 in Exclude<keyof I, keyof PositionLiquidatedEvent>]: never; }>(base?: I | undefined): PositionLiquidatedEvent;
    fromPartial<I_1 extends {
        positionChangedEvent?: {
            finalPosition?: {
                traderAddress?: string | undefined;
                pair?: string | undefined;
                size?: string | undefined;
                margin?: string | undefined;
                openNotional?: string | undefined;
                latestCumulativePremiumFraction?: string | undefined;
                lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
            } | undefined;
            positionNotional?: string | undefined;
            transactionFee?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
            realizedPnl?: string | undefined;
            badDebt?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
            fundingPayment?: string | undefined;
            blockHeight?: string | number | Long.Long | undefined;
            marginToUser?: string | undefined;
            changeReason?: string | undefined;
        } | undefined;
        liquidatorAddress?: string | undefined;
        feeToLiquidator?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        feeToEcosystemFund?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
    } & {
        positionChangedEvent?: ({
            finalPosition?: {
                traderAddress?: string | undefined;
                pair?: string | undefined;
                size?: string | undefined;
                margin?: string | undefined;
                openNotional?: string | undefined;
                latestCumulativePremiumFraction?: string | undefined;
                lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
            } | undefined;
            positionNotional?: string | undefined;
            transactionFee?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
            realizedPnl?: string | undefined;
            badDebt?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
            fundingPayment?: string | undefined;
            blockHeight?: string | number | Long.Long | undefined;
            marginToUser?: string | undefined;
            changeReason?: string | undefined;
        } & {
            finalPosition?: ({
                traderAddress?: string | undefined;
                pair?: string | undefined;
                size?: string | undefined;
                margin?: string | undefined;
                openNotional?: string | undefined;
                latestCumulativePremiumFraction?: string | undefined;
                lastUpdatedBlockNumber?: string | number | Long.Long | undefined;
            } & {
                traderAddress?: string | undefined;
                pair?: string | undefined;
                size?: string | undefined;
                margin?: string | undefined;
                openNotional?: string | undefined;
                latestCumulativePremiumFraction?: string | undefined;
                lastUpdatedBlockNumber?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & { [K_9 in Exclude<keyof I_1["positionChangedEvent"]["finalPosition"]["lastUpdatedBlockNumber"], keyof Long.Long>]: never; }) | undefined;
            } & { [K_10 in Exclude<keyof I_1["positionChangedEvent"]["finalPosition"], keyof Position>]: never; }) | undefined;
            positionNotional?: string | undefined;
            transactionFee?: ({
                denom?: string | undefined;
                amount?: string | undefined;
            } & {
                denom?: string | undefined;
                amount?: string | undefined;
            } & { [K_11 in Exclude<keyof I_1["positionChangedEvent"]["transactionFee"], keyof Coin>]: never; }) | undefined;
            realizedPnl?: string | undefined;
            badDebt?: ({
                denom?: string | undefined;
                amount?: string | undefined;
            } & {
                denom?: string | undefined;
                amount?: string | undefined;
            } & { [K_12 in Exclude<keyof I_1["positionChangedEvent"]["badDebt"], keyof Coin>]: never; }) | undefined;
            fundingPayment?: string | undefined;
            blockHeight?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & { [K_13 in Exclude<keyof I_1["positionChangedEvent"]["blockHeight"], keyof Long.Long>]: never; }) | undefined;
            marginToUser?: string | undefined;
            changeReason?: string | undefined;
        } & { [K_14 in Exclude<keyof I_1["positionChangedEvent"], keyof PositionChangedEvent>]: never; }) | undefined;
        liquidatorAddress?: string | undefined;
        feeToLiquidator?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_15 in Exclude<keyof I_1["feeToLiquidator"], keyof Coin>]: never; }) | undefined;
        feeToEcosystemFund?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_16 in Exclude<keyof I_1["feeToEcosystemFund"], keyof Coin>]: never; }) | undefined;
    } & { [K_17 in Exclude<keyof I_1, keyof PositionLiquidatedEvent>]: never; }>(object: I_1): PositionLiquidatedEvent;
};
export declare const PositionSettledEvent: {
    encode(message: PositionSettledEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PositionSettledEvent;
    fromJSON(object: any): PositionSettledEvent;
    toJSON(message: PositionSettledEvent): unknown;
    create<I extends {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        settledCoins?: {
            denom?: string | undefined;
            amount?: string | undefined;
        }[] | undefined;
    } & {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        settledCoins?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K in Exclude<keyof I["settledCoins"][number], keyof Coin>]: never; })[] & { [K_1 in Exclude<keyof I["settledCoins"], keyof {
            denom?: string | undefined;
            amount?: string | undefined;
        }[]>]: never; }) | undefined;
    } & { [K_2 in Exclude<keyof I, keyof PositionSettledEvent>]: never; }>(base?: I | undefined): PositionSettledEvent;
    fromPartial<I_1 extends {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        settledCoins?: {
            denom?: string | undefined;
            amount?: string | undefined;
        }[] | undefined;
    } & {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        settledCoins?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_3 in Exclude<keyof I_1["settledCoins"][number], keyof Coin>]: never; })[] & { [K_4 in Exclude<keyof I_1["settledCoins"], keyof {
            denom?: string | undefined;
            amount?: string | undefined;
        }[]>]: never; }) | undefined;
    } & { [K_5 in Exclude<keyof I_1, keyof PositionSettledEvent>]: never; }>(object: I_1): PositionSettledEvent;
};
export declare const FundingRateChangedEvent: {
    encode(message: FundingRateChangedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FundingRateChangedEvent;
    fromJSON(object: any): FundingRateChangedEvent;
    toJSON(message: FundingRateChangedEvent): unknown;
    create<I extends {
        pair?: string | undefined;
        markPriceTwap?: string | undefined;
        indexPriceTwap?: string | undefined;
        premiumFraction?: string | undefined;
        cumulativePremiumFraction?: string | undefined;
    } & {
        pair?: string | undefined;
        markPriceTwap?: string | undefined;
        indexPriceTwap?: string | undefined;
        premiumFraction?: string | undefined;
        cumulativePremiumFraction?: string | undefined;
    } & { [K in Exclude<keyof I, keyof FundingRateChangedEvent>]: never; }>(base?: I | undefined): FundingRateChangedEvent;
    fromPartial<I_1 extends {
        pair?: string | undefined;
        markPriceTwap?: string | undefined;
        indexPriceTwap?: string | undefined;
        premiumFraction?: string | undefined;
        cumulativePremiumFraction?: string | undefined;
    } & {
        pair?: string | undefined;
        markPriceTwap?: string | undefined;
        indexPriceTwap?: string | undefined;
        premiumFraction?: string | undefined;
        cumulativePremiumFraction?: string | undefined;
    } & { [K_1 in Exclude<keyof I_1, keyof FundingRateChangedEvent>]: never; }>(object: I_1): FundingRateChangedEvent;
};
export declare const LiquidationFailedEvent: {
    encode(message: LiquidationFailedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LiquidationFailedEvent;
    fromJSON(object: any): LiquidationFailedEvent;
    toJSON(message: LiquidationFailedEvent): unknown;
    create<I extends {
        pair?: string | undefined;
        trader?: string | undefined;
        liquidator?: string | undefined;
        reason?: LiquidationFailedEvent_LiquidationFailedReason | undefined;
    } & {
        pair?: string | undefined;
        trader?: string | undefined;
        liquidator?: string | undefined;
        reason?: LiquidationFailedEvent_LiquidationFailedReason | undefined;
    } & { [K in Exclude<keyof I, keyof LiquidationFailedEvent>]: never; }>(base?: I | undefined): LiquidationFailedEvent;
    fromPartial<I_1 extends {
        pair?: string | undefined;
        trader?: string | undefined;
        liquidator?: string | undefined;
        reason?: LiquidationFailedEvent_LiquidationFailedReason | undefined;
    } & {
        pair?: string | undefined;
        trader?: string | undefined;
        liquidator?: string | undefined;
        reason?: LiquidationFailedEvent_LiquidationFailedReason | undefined;
    } & { [K_1 in Exclude<keyof I_1, keyof LiquidationFailedEvent>]: never; }>(object: I_1): LiquidationFailedEvent;
};
export declare const AmmUpdatedEvent: {
    encode(message: AmmUpdatedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AmmUpdatedEvent;
    fromJSON(object: any): AmmUpdatedEvent;
    toJSON(message: AmmUpdatedEvent): unknown;
    create<I extends {
        finalAmm?: {
            pair?: string | undefined;
            baseReserve?: string | undefined;
            quoteReserve?: string | undefined;
            sqrtDepth?: string | undefined;
            priceMultiplier?: string | undefined;
            totalLong?: string | undefined;
            totalShort?: string | undefined;
        } | undefined;
        markPriceTwap?: string | undefined;
        indexPriceTwap?: string | undefined;
    } & {
        finalAmm?: ({
            pair?: string | undefined;
            baseReserve?: string | undefined;
            quoteReserve?: string | undefined;
            sqrtDepth?: string | undefined;
            priceMultiplier?: string | undefined;
            totalLong?: string | undefined;
            totalShort?: string | undefined;
        } & {
            pair?: string | undefined;
            baseReserve?: string | undefined;
            quoteReserve?: string | undefined;
            sqrtDepth?: string | undefined;
            priceMultiplier?: string | undefined;
            totalLong?: string | undefined;
            totalShort?: string | undefined;
        } & { [K in Exclude<keyof I["finalAmm"], keyof AMM>]: never; }) | undefined;
        markPriceTwap?: string | undefined;
        indexPriceTwap?: string | undefined;
    } & { [K_1 in Exclude<keyof I, keyof AmmUpdatedEvent>]: never; }>(base?: I | undefined): AmmUpdatedEvent;
    fromPartial<I_1 extends {
        finalAmm?: {
            pair?: string | undefined;
            baseReserve?: string | undefined;
            quoteReserve?: string | undefined;
            sqrtDepth?: string | undefined;
            priceMultiplier?: string | undefined;
            totalLong?: string | undefined;
            totalShort?: string | undefined;
        } | undefined;
        markPriceTwap?: string | undefined;
        indexPriceTwap?: string | undefined;
    } & {
        finalAmm?: ({
            pair?: string | undefined;
            baseReserve?: string | undefined;
            quoteReserve?: string | undefined;
            sqrtDepth?: string | undefined;
            priceMultiplier?: string | undefined;
            totalLong?: string | undefined;
            totalShort?: string | undefined;
        } & {
            pair?: string | undefined;
            baseReserve?: string | undefined;
            quoteReserve?: string | undefined;
            sqrtDepth?: string | undefined;
            priceMultiplier?: string | undefined;
            totalLong?: string | undefined;
            totalShort?: string | undefined;
        } & { [K_2 in Exclude<keyof I_1["finalAmm"], keyof AMM>]: never; }) | undefined;
        markPriceTwap?: string | undefined;
        indexPriceTwap?: string | undefined;
    } & { [K_3 in Exclude<keyof I_1, keyof AmmUpdatedEvent>]: never; }>(object: I_1): AmmUpdatedEvent;
};
export declare const MarketUpdatedEvent: {
    encode(message: MarketUpdatedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MarketUpdatedEvent;
    fromJSON(object: any): MarketUpdatedEvent;
    toJSON(message: MarketUpdatedEvent): unknown;
    create<I extends {
        finalMarket?: {
            pair?: string | undefined;
            enabled?: boolean | undefined;
            maintenanceMarginRatio?: string | undefined;
            maxLeverage?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            exchangeFeeRatio?: string | undefined;
            ecosystemFundFeeRatio?: string | undefined;
            liquidationFeeRatio?: string | undefined;
            partialLiquidationRatio?: string | undefined;
            fundingRateEpochId?: string | undefined;
            twapLookbackWindow?: {
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } | undefined;
            prepaidBadDebt?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
        } | undefined;
    } & {
        finalMarket?: ({
            pair?: string | undefined;
            enabled?: boolean | undefined;
            maintenanceMarginRatio?: string | undefined;
            maxLeverage?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            exchangeFeeRatio?: string | undefined;
            ecosystemFundFeeRatio?: string | undefined;
            liquidationFeeRatio?: string | undefined;
            partialLiquidationRatio?: string | undefined;
            fundingRateEpochId?: string | undefined;
            twapLookbackWindow?: {
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } | undefined;
            prepaidBadDebt?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
        } & {
            pair?: string | undefined;
            enabled?: boolean | undefined;
            maintenanceMarginRatio?: string | undefined;
            maxLeverage?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            exchangeFeeRatio?: string | undefined;
            ecosystemFundFeeRatio?: string | undefined;
            liquidationFeeRatio?: string | undefined;
            partialLiquidationRatio?: string | undefined;
            fundingRateEpochId?: string | undefined;
            twapLookbackWindow?: ({
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & { [K in Exclude<keyof I["finalMarket"]["twapLookbackWindow"]["seconds"], keyof Long.Long>]: never; }) | undefined;
                nanos?: number | undefined;
            } & { [K_1 in Exclude<keyof I["finalMarket"]["twapLookbackWindow"], keyof import("../../../google/protobuf/duration").Duration>]: never; }) | undefined;
            prepaidBadDebt?: ({
                denom?: string | undefined;
                amount?: string | undefined;
            } & {
                denom?: string | undefined;
                amount?: string | undefined;
            } & { [K_2 in Exclude<keyof I["finalMarket"]["prepaidBadDebt"], keyof Coin>]: never; }) | undefined;
        } & { [K_3 in Exclude<keyof I["finalMarket"], keyof Market>]: never; }) | undefined;
    } & { [K_4 in Exclude<keyof I, "finalMarket">]: never; }>(base?: I | undefined): MarketUpdatedEvent;
    fromPartial<I_1 extends {
        finalMarket?: {
            pair?: string | undefined;
            enabled?: boolean | undefined;
            maintenanceMarginRatio?: string | undefined;
            maxLeverage?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            exchangeFeeRatio?: string | undefined;
            ecosystemFundFeeRatio?: string | undefined;
            liquidationFeeRatio?: string | undefined;
            partialLiquidationRatio?: string | undefined;
            fundingRateEpochId?: string | undefined;
            twapLookbackWindow?: {
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } | undefined;
            prepaidBadDebt?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
        } | undefined;
    } & {
        finalMarket?: ({
            pair?: string | undefined;
            enabled?: boolean | undefined;
            maintenanceMarginRatio?: string | undefined;
            maxLeverage?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            exchangeFeeRatio?: string | undefined;
            ecosystemFundFeeRatio?: string | undefined;
            liquidationFeeRatio?: string | undefined;
            partialLiquidationRatio?: string | undefined;
            fundingRateEpochId?: string | undefined;
            twapLookbackWindow?: {
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } | undefined;
            prepaidBadDebt?: {
                denom?: string | undefined;
                amount?: string | undefined;
            } | undefined;
        } & {
            pair?: string | undefined;
            enabled?: boolean | undefined;
            maintenanceMarginRatio?: string | undefined;
            maxLeverage?: string | undefined;
            latestCumulativePremiumFraction?: string | undefined;
            exchangeFeeRatio?: string | undefined;
            ecosystemFundFeeRatio?: string | undefined;
            liquidationFeeRatio?: string | undefined;
            partialLiquidationRatio?: string | undefined;
            fundingRateEpochId?: string | undefined;
            twapLookbackWindow?: ({
                seconds?: string | number | Long.Long | undefined;
                nanos?: number | undefined;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & { [K_5 in Exclude<keyof I_1["finalMarket"]["twapLookbackWindow"]["seconds"], keyof Long.Long>]: never; }) | undefined;
                nanos?: number | undefined;
            } & { [K_6 in Exclude<keyof I_1["finalMarket"]["twapLookbackWindow"], keyof import("../../../google/protobuf/duration").Duration>]: never; }) | undefined;
            prepaidBadDebt?: ({
                denom?: string | undefined;
                amount?: string | undefined;
            } & {
                denom?: string | undefined;
                amount?: string | undefined;
            } & { [K_7 in Exclude<keyof I_1["finalMarket"]["prepaidBadDebt"], keyof Coin>]: never; }) | undefined;
        } & { [K_8 in Exclude<keyof I_1["finalMarket"], keyof Market>]: never; }) | undefined;
    } & { [K_9 in Exclude<keyof I_1, "finalMarket">]: never; }>(object: I_1): MarketUpdatedEvent;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
declare type KeysOfUnion<T> = T extends T ? keyof T : never;
export declare type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
//# sourceMappingURL=event.d.ts.map