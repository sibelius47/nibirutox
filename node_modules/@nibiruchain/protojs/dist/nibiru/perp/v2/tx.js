"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgClientImpl = exports.MsgServiceName = exports.MsgDonateToEcosystemFundResponse = exports.MsgDonateToEcosystemFund = exports.MsgPartialCloseResponse = exports.MsgPartialClose = exports.MsgClosePositionResponse = exports.MsgClosePosition = exports.MsgMarketOrderResponse = exports.MsgMarketOrder = exports.MsgMultiLiquidateResponse_LiquidationResponse = exports.MsgMultiLiquidateResponse = exports.MsgMultiLiquidate_Liquidation = exports.MsgMultiLiquidate = exports.MsgAddMarginResponse = exports.MsgAddMargin = exports.MsgRemoveMarginResponse = exports.MsgRemoveMargin = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
const state_1 = require("./state");
exports.protobufPackage = "nibiru.perp.v2";
function createBaseMsgRemoveMargin() {
    return { sender: "", pair: "", margin: undefined };
}
exports.MsgRemoveMargin = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        if (message.margin !== undefined) {
            coin_1.Coin.encode(message.margin, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveMargin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pair = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.margin = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
            margin: isSet(object.margin) ? coin_1.Coin.fromJSON(object.margin) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.pair !== undefined && (obj.pair = message.pair);
        message.margin !== undefined &&
            (obj.margin = message.margin ? coin_1.Coin.toJSON(message.margin) : undefined);
        return obj;
    },
    create(base) {
        return exports.MsgRemoveMargin.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgRemoveMargin();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        message.margin =
            object.margin !== undefined && object.margin !== null
                ? coin_1.Coin.fromPartial(object.margin)
                : undefined;
        return message;
    },
};
function createBaseMsgRemoveMarginResponse() {
    return { marginOut: undefined, fundingPayment: "", position: undefined };
}
exports.MsgRemoveMarginResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.marginOut !== undefined) {
            coin_1.Coin.encode(message.marginOut, writer.uint32(10).fork()).ldelim();
        }
        if (message.fundingPayment !== "") {
            writer.uint32(18).string(message.fundingPayment);
        }
        if (message.position !== undefined) {
            state_1.Position.encode(message.position, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveMarginResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.marginOut = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fundingPayment = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.position = state_1.Position.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            marginOut: isSet(object.marginOut)
                ? coin_1.Coin.fromJSON(object.marginOut)
                : undefined,
            fundingPayment: isSet(object.fundingPayment)
                ? String(object.fundingPayment)
                : "",
            position: isSet(object.position)
                ? state_1.Position.fromJSON(object.position)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.marginOut !== undefined &&
            (obj.marginOut = message.marginOut
                ? coin_1.Coin.toJSON(message.marginOut)
                : undefined);
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.position !== undefined &&
            (obj.position = message.position
                ? state_1.Position.toJSON(message.position)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.MsgRemoveMarginResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgRemoveMarginResponse();
        message.marginOut =
            object.marginOut !== undefined && object.marginOut !== null
                ? coin_1.Coin.fromPartial(object.marginOut)
                : undefined;
        message.fundingPayment = (_a = object.fundingPayment) !== null && _a !== void 0 ? _a : "";
        message.position =
            object.position !== undefined && object.position !== null
                ? state_1.Position.fromPartial(object.position)
                : undefined;
        return message;
    },
};
function createBaseMsgAddMargin() {
    return { sender: "", pair: "", margin: undefined };
}
exports.MsgAddMargin = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        if (message.margin !== undefined) {
            coin_1.Coin.encode(message.margin, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddMargin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pair = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.margin = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
            margin: isSet(object.margin) ? coin_1.Coin.fromJSON(object.margin) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.pair !== undefined && (obj.pair = message.pair);
        message.margin !== undefined &&
            (obj.margin = message.margin ? coin_1.Coin.toJSON(message.margin) : undefined);
        return obj;
    },
    create(base) {
        return exports.MsgAddMargin.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgAddMargin();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        message.margin =
            object.margin !== undefined && object.margin !== null
                ? coin_1.Coin.fromPartial(object.margin)
                : undefined;
        return message;
    },
};
function createBaseMsgAddMarginResponse() {
    return { fundingPayment: "", position: undefined };
}
exports.MsgAddMarginResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fundingPayment !== "") {
            writer.uint32(10).string(message.fundingPayment);
        }
        if (message.position !== undefined) {
            state_1.Position.encode(message.position, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddMarginResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fundingPayment = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.position = state_1.Position.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            fundingPayment: isSet(object.fundingPayment)
                ? String(object.fundingPayment)
                : "",
            position: isSet(object.position)
                ? state_1.Position.fromJSON(object.position)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.position !== undefined &&
            (obj.position = message.position
                ? state_1.Position.toJSON(message.position)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.MsgAddMarginResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgAddMarginResponse();
        message.fundingPayment = (_a = object.fundingPayment) !== null && _a !== void 0 ? _a : "";
        message.position =
            object.position !== undefined && object.position !== null
                ? state_1.Position.fromPartial(object.position)
                : undefined;
        return message;
    },
};
function createBaseMsgMultiLiquidate() {
    return { sender: "", liquidations: [] };
}
exports.MsgMultiLiquidate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        for (const v of message.liquidations) {
            exports.MsgMultiLiquidate_Liquidation.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiLiquidate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.liquidations.push(exports.MsgMultiLiquidate_Liquidation.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            liquidations: Array.isArray(object === null || object === void 0 ? void 0 : object.liquidations)
                ? object.liquidations.map((e) => exports.MsgMultiLiquidate_Liquidation.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        if (message.liquidations) {
            obj.liquidations = message.liquidations.map((e) => e ? exports.MsgMultiLiquidate_Liquidation.toJSON(e) : undefined);
        }
        else {
            obj.liquidations = [];
        }
        return obj;
    },
    create(base) {
        return exports.MsgMultiLiquidate.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgMultiLiquidate();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.liquidations =
            ((_b = object.liquidations) === null || _b === void 0 ? void 0 : _b.map((e) => exports.MsgMultiLiquidate_Liquidation.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMsgMultiLiquidate_Liquidation() {
    return { pair: "", trader: "" };
}
exports.MsgMultiLiquidate_Liquidation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.trader !== "") {
            writer.uint32(18).string(message.trader);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiLiquidate_Liquidation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pair = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.trader = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            trader: isSet(object.trader) ? String(object.trader) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.trader !== undefined && (obj.trader = message.trader);
        return obj;
    },
    create(base) {
        return exports.MsgMultiLiquidate_Liquidation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgMultiLiquidate_Liquidation();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.trader = (_b = object.trader) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgMultiLiquidateResponse() {
    return { liquidations: [] };
}
exports.MsgMultiLiquidateResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.liquidations) {
            exports.MsgMultiLiquidateResponse_LiquidationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiLiquidateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.liquidations.push(exports.MsgMultiLiquidateResponse_LiquidationResponse.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            liquidations: Array.isArray(object === null || object === void 0 ? void 0 : object.liquidations)
                ? object.liquidations.map((e) => exports.MsgMultiLiquidateResponse_LiquidationResponse.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.liquidations) {
            obj.liquidations = message.liquidations.map((e) => e ? exports.MsgMultiLiquidateResponse_LiquidationResponse.toJSON(e) : undefined);
        }
        else {
            obj.liquidations = [];
        }
        return obj;
    },
    create(base) {
        return exports.MsgMultiLiquidateResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgMultiLiquidateResponse();
        message.liquidations =
            ((_a = object.liquidations) === null || _a === void 0 ? void 0 : _a.map((e) => exports.MsgMultiLiquidateResponse_LiquidationResponse.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMsgMultiLiquidateResponse_LiquidationResponse() {
    return {
        success: false,
        error: "",
        liquidatorFee: undefined,
        perpEfFee: undefined,
        trader: "",
        pair: "",
    };
}
exports.MsgMultiLiquidateResponse_LiquidationResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.success === true) {
            writer.uint32(8).bool(message.success);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        if (message.liquidatorFee !== undefined) {
            coin_1.Coin.encode(message.liquidatorFee, writer.uint32(26).fork()).ldelim();
        }
        if (message.perpEfFee !== undefined) {
            coin_1.Coin.encode(message.perpEfFee, writer.uint32(34).fork()).ldelim();
        }
        if (message.trader !== "") {
            writer.uint32(42).string(message.trader);
        }
        if (message.pair !== "") {
            writer.uint32(50).string(message.pair);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiLiquidateResponse_LiquidationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.liquidatorFee = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.perpEfFee = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.trader = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.pair = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? Boolean(object.success) : false,
            error: isSet(object.error) ? String(object.error) : "",
            liquidatorFee: isSet(object.liquidatorFee)
                ? coin_1.Coin.fromJSON(object.liquidatorFee)
                : undefined,
            perpEfFee: isSet(object.perpEfFee)
                ? coin_1.Coin.fromJSON(object.perpEfFee)
                : undefined,
            trader: isSet(object.trader) ? String(object.trader) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.success !== undefined && (obj.success = message.success);
        message.error !== undefined && (obj.error = message.error);
        message.liquidatorFee !== undefined &&
            (obj.liquidatorFee = message.liquidatorFee
                ? coin_1.Coin.toJSON(message.liquidatorFee)
                : undefined);
        message.perpEfFee !== undefined &&
            (obj.perpEfFee = message.perpEfFee
                ? coin_1.Coin.toJSON(message.perpEfFee)
                : undefined);
        message.trader !== undefined && (obj.trader = message.trader);
        message.pair !== undefined && (obj.pair = message.pair);
        return obj;
    },
    create(base) {
        return exports.MsgMultiLiquidateResponse_LiquidationResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgMultiLiquidateResponse_LiquidationResponse();
        message.success = (_a = object.success) !== null && _a !== void 0 ? _a : false;
        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : "";
        message.liquidatorFee =
            object.liquidatorFee !== undefined && object.liquidatorFee !== null
                ? coin_1.Coin.fromPartial(object.liquidatorFee)
                : undefined;
        message.perpEfFee =
            object.perpEfFee !== undefined && object.perpEfFee !== null
                ? coin_1.Coin.fromPartial(object.perpEfFee)
                : undefined;
        message.trader = (_c = object.trader) !== null && _c !== void 0 ? _c : "";
        message.pair = (_d = object.pair) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseMsgMarketOrder() {
    return {
        sender: "",
        pair: "",
        side: 0,
        quoteAssetAmount: "",
        leverage: "",
        baseAssetAmountLimit: "",
    };
}
exports.MsgMarketOrder = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        if (message.side !== 0) {
            writer.uint32(24).int32(message.side);
        }
        if (message.quoteAssetAmount !== "") {
            writer.uint32(34).string(message.quoteAssetAmount);
        }
        if (message.leverage !== "") {
            writer.uint32(42).string(message.leverage);
        }
        if (message.baseAssetAmountLimit !== "") {
            writer.uint32(50).string(message.baseAssetAmountLimit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMarketOrder();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pair = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.side = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.quoteAssetAmount = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.leverage = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.baseAssetAmountLimit = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
            side: isSet(object.side) ? (0, state_1.directionFromJSON)(object.side) : 0,
            quoteAssetAmount: isSet(object.quoteAssetAmount)
                ? String(object.quoteAssetAmount)
                : "",
            leverage: isSet(object.leverage) ? String(object.leverage) : "",
            baseAssetAmountLimit: isSet(object.baseAssetAmountLimit)
                ? String(object.baseAssetAmountLimit)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.pair !== undefined && (obj.pair = message.pair);
        message.side !== undefined && (obj.side = (0, state_1.directionToJSON)(message.side));
        message.quoteAssetAmount !== undefined &&
            (obj.quoteAssetAmount = message.quoteAssetAmount);
        message.leverage !== undefined && (obj.leverage = message.leverage);
        message.baseAssetAmountLimit !== undefined &&
            (obj.baseAssetAmountLimit = message.baseAssetAmountLimit);
        return obj;
    },
    create(base) {
        return exports.MsgMarketOrder.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMsgMarketOrder();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        message.side = (_c = object.side) !== null && _c !== void 0 ? _c : 0;
        message.quoteAssetAmount = (_d = object.quoteAssetAmount) !== null && _d !== void 0 ? _d : "";
        message.leverage = (_e = object.leverage) !== null && _e !== void 0 ? _e : "";
        message.baseAssetAmountLimit = (_f = object.baseAssetAmountLimit) !== null && _f !== void 0 ? _f : "";
        return message;
    },
};
function createBaseMsgMarketOrderResponse() {
    return {
        position: undefined,
        exchangedNotionalValue: "",
        exchangedPositionSize: "",
        fundingPayment: "",
        realizedPnl: "",
        unrealizedPnlAfter: "",
        marginToVault: "",
        positionNotional: "",
    };
}
exports.MsgMarketOrderResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.position !== undefined) {
            state_1.Position.encode(message.position, writer.uint32(10).fork()).ldelim();
        }
        if (message.exchangedNotionalValue !== "") {
            writer.uint32(18).string(message.exchangedNotionalValue);
        }
        if (message.exchangedPositionSize !== "") {
            writer.uint32(26).string(message.exchangedPositionSize);
        }
        if (message.fundingPayment !== "") {
            writer.uint32(34).string(message.fundingPayment);
        }
        if (message.realizedPnl !== "") {
            writer.uint32(42).string(message.realizedPnl);
        }
        if (message.unrealizedPnlAfter !== "") {
            writer.uint32(50).string(message.unrealizedPnlAfter);
        }
        if (message.marginToVault !== "") {
            writer.uint32(58).string(message.marginToVault);
        }
        if (message.positionNotional !== "") {
            writer.uint32(66).string(message.positionNotional);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMarketOrderResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.position = state_1.Position.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.exchangedNotionalValue = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.exchangedPositionSize = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.fundingPayment = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.realizedPnl = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.unrealizedPnlAfter = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.marginToVault = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.positionNotional = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            position: isSet(object.position)
                ? state_1.Position.fromJSON(object.position)
                : undefined,
            exchangedNotionalValue: isSet(object.exchangedNotionalValue)
                ? String(object.exchangedNotionalValue)
                : "",
            exchangedPositionSize: isSet(object.exchangedPositionSize)
                ? String(object.exchangedPositionSize)
                : "",
            fundingPayment: isSet(object.fundingPayment)
                ? String(object.fundingPayment)
                : "",
            realizedPnl: isSet(object.realizedPnl) ? String(object.realizedPnl) : "",
            unrealizedPnlAfter: isSet(object.unrealizedPnlAfter)
                ? String(object.unrealizedPnlAfter)
                : "",
            marginToVault: isSet(object.marginToVault)
                ? String(object.marginToVault)
                : "",
            positionNotional: isSet(object.positionNotional)
                ? String(object.positionNotional)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.position !== undefined &&
            (obj.position = message.position
                ? state_1.Position.toJSON(message.position)
                : undefined);
        message.exchangedNotionalValue !== undefined &&
            (obj.exchangedNotionalValue = message.exchangedNotionalValue);
        message.exchangedPositionSize !== undefined &&
            (obj.exchangedPositionSize = message.exchangedPositionSize);
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.realizedPnl !== undefined && (obj.realizedPnl = message.realizedPnl);
        message.unrealizedPnlAfter !== undefined &&
            (obj.unrealizedPnlAfter = message.unrealizedPnlAfter);
        message.marginToVault !== undefined &&
            (obj.marginToVault = message.marginToVault);
        message.positionNotional !== undefined &&
            (obj.positionNotional = message.positionNotional);
        return obj;
    },
    create(base) {
        return exports.MsgMarketOrderResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseMsgMarketOrderResponse();
        message.position =
            object.position !== undefined && object.position !== null
                ? state_1.Position.fromPartial(object.position)
                : undefined;
        message.exchangedNotionalValue = (_a = object.exchangedNotionalValue) !== null && _a !== void 0 ? _a : "";
        message.exchangedPositionSize = (_b = object.exchangedPositionSize) !== null && _b !== void 0 ? _b : "";
        message.fundingPayment = (_c = object.fundingPayment) !== null && _c !== void 0 ? _c : "";
        message.realizedPnl = (_d = object.realizedPnl) !== null && _d !== void 0 ? _d : "";
        message.unrealizedPnlAfter = (_e = object.unrealizedPnlAfter) !== null && _e !== void 0 ? _e : "";
        message.marginToVault = (_f = object.marginToVault) !== null && _f !== void 0 ? _f : "";
        message.positionNotional = (_g = object.positionNotional) !== null && _g !== void 0 ? _g : "";
        return message;
    },
};
function createBaseMsgClosePosition() {
    return { sender: "", pair: "" };
}
exports.MsgClosePosition = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClosePosition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pair = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.pair !== undefined && (obj.pair = message.pair);
        return obj;
    },
    create(base) {
        return exports.MsgClosePosition.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgClosePosition();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgClosePositionResponse() {
    return {
        exchangedNotionalValue: "",
        exchangedPositionSize: "",
        fundingPayment: "",
        realizedPnl: "",
        marginToTrader: "",
    };
}
exports.MsgClosePositionResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exchangedNotionalValue !== "") {
            writer.uint32(10).string(message.exchangedNotionalValue);
        }
        if (message.exchangedPositionSize !== "") {
            writer.uint32(18).string(message.exchangedPositionSize);
        }
        if (message.fundingPayment !== "") {
            writer.uint32(26).string(message.fundingPayment);
        }
        if (message.realizedPnl !== "") {
            writer.uint32(34).string(message.realizedPnl);
        }
        if (message.marginToTrader !== "") {
            writer.uint32(42).string(message.marginToTrader);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClosePositionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.exchangedNotionalValue = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.exchangedPositionSize = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.fundingPayment = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.realizedPnl = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.marginToTrader = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            exchangedNotionalValue: isSet(object.exchangedNotionalValue)
                ? String(object.exchangedNotionalValue)
                : "",
            exchangedPositionSize: isSet(object.exchangedPositionSize)
                ? String(object.exchangedPositionSize)
                : "",
            fundingPayment: isSet(object.fundingPayment)
                ? String(object.fundingPayment)
                : "",
            realizedPnl: isSet(object.realizedPnl) ? String(object.realizedPnl) : "",
            marginToTrader: isSet(object.marginToTrader)
                ? String(object.marginToTrader)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.exchangedNotionalValue !== undefined &&
            (obj.exchangedNotionalValue = message.exchangedNotionalValue);
        message.exchangedPositionSize !== undefined &&
            (obj.exchangedPositionSize = message.exchangedPositionSize);
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.realizedPnl !== undefined && (obj.realizedPnl = message.realizedPnl);
        message.marginToTrader !== undefined &&
            (obj.marginToTrader = message.marginToTrader);
        return obj;
    },
    create(base) {
        return exports.MsgClosePositionResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgClosePositionResponse();
        message.exchangedNotionalValue = (_a = object.exchangedNotionalValue) !== null && _a !== void 0 ? _a : "";
        message.exchangedPositionSize = (_b = object.exchangedPositionSize) !== null && _b !== void 0 ? _b : "";
        message.fundingPayment = (_c = object.fundingPayment) !== null && _c !== void 0 ? _c : "";
        message.realizedPnl = (_d = object.realizedPnl) !== null && _d !== void 0 ? _d : "";
        message.marginToTrader = (_e = object.marginToTrader) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseMsgPartialClose() {
    return { sender: "", pair: "", size: "" };
}
exports.MsgPartialClose = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        if (message.size !== "") {
            writer.uint32(26).string(message.size);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPartialClose();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pair = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.size = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
            size: isSet(object.size) ? String(object.size) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.pair !== undefined && (obj.pair = message.pair);
        message.size !== undefined && (obj.size = message.size);
        return obj;
    },
    create(base) {
        return exports.MsgPartialClose.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgPartialClose();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        message.size = (_c = object.size) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgPartialCloseResponse() {
    return {
        exchangedNotionalValue: "",
        exchangedPositionSize: "",
        fundingPayment: "",
        realizedPnl: "",
        marginToTrader: "",
    };
}
exports.MsgPartialCloseResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exchangedNotionalValue !== "") {
            writer.uint32(10).string(message.exchangedNotionalValue);
        }
        if (message.exchangedPositionSize !== "") {
            writer.uint32(18).string(message.exchangedPositionSize);
        }
        if (message.fundingPayment !== "") {
            writer.uint32(26).string(message.fundingPayment);
        }
        if (message.realizedPnl !== "") {
            writer.uint32(34).string(message.realizedPnl);
        }
        if (message.marginToTrader !== "") {
            writer.uint32(42).string(message.marginToTrader);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPartialCloseResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.exchangedNotionalValue = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.exchangedPositionSize = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.fundingPayment = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.realizedPnl = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.marginToTrader = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            exchangedNotionalValue: isSet(object.exchangedNotionalValue)
                ? String(object.exchangedNotionalValue)
                : "",
            exchangedPositionSize: isSet(object.exchangedPositionSize)
                ? String(object.exchangedPositionSize)
                : "",
            fundingPayment: isSet(object.fundingPayment)
                ? String(object.fundingPayment)
                : "",
            realizedPnl: isSet(object.realizedPnl) ? String(object.realizedPnl) : "",
            marginToTrader: isSet(object.marginToTrader)
                ? String(object.marginToTrader)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.exchangedNotionalValue !== undefined &&
            (obj.exchangedNotionalValue = message.exchangedNotionalValue);
        message.exchangedPositionSize !== undefined &&
            (obj.exchangedPositionSize = message.exchangedPositionSize);
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.realizedPnl !== undefined && (obj.realizedPnl = message.realizedPnl);
        message.marginToTrader !== undefined &&
            (obj.marginToTrader = message.marginToTrader);
        return obj;
    },
    create(base) {
        return exports.MsgPartialCloseResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgPartialCloseResponse();
        message.exchangedNotionalValue = (_a = object.exchangedNotionalValue) !== null && _a !== void 0 ? _a : "";
        message.exchangedPositionSize = (_b = object.exchangedPositionSize) !== null && _b !== void 0 ? _b : "";
        message.fundingPayment = (_c = object.fundingPayment) !== null && _c !== void 0 ? _c : "";
        message.realizedPnl = (_d = object.realizedPnl) !== null && _d !== void 0 ? _d : "";
        message.marginToTrader = (_e = object.marginToTrader) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseMsgDonateToEcosystemFund() {
    return { sender: "", donation: undefined };
}
exports.MsgDonateToEcosystemFund = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.donation !== undefined) {
            coin_1.Coin.encode(message.donation, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDonateToEcosystemFund();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.donation = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            donation: isSet(object.donation)
                ? coin_1.Coin.fromJSON(object.donation)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.donation !== undefined &&
            (obj.donation = message.donation
                ? coin_1.Coin.toJSON(message.donation)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.MsgDonateToEcosystemFund.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgDonateToEcosystemFund();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.donation =
            object.donation !== undefined && object.donation !== null
                ? coin_1.Coin.fromPartial(object.donation)
                : undefined;
        return message;
    },
};
function createBaseMsgDonateToEcosystemFundResponse() {
    return {};
}
exports.MsgDonateToEcosystemFundResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDonateToEcosystemFundResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgDonateToEcosystemFundResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgDonateToEcosystemFundResponse();
        return message;
    },
};
exports.MsgServiceName = "nibiru.perp.v2.Msg";
class MsgClientImpl {
    constructor(rpc, opts) {
        this.service = (opts === null || opts === void 0 ? void 0 : opts.service) || exports.MsgServiceName;
        this.rpc = rpc;
        this.RemoveMargin = this.RemoveMargin.bind(this);
        this.AddMargin = this.AddMargin.bind(this);
        this.MultiLiquidate = this.MultiLiquidate.bind(this);
        this.MarketOrder = this.MarketOrder.bind(this);
        this.ClosePosition = this.ClosePosition.bind(this);
        this.PartialClose = this.PartialClose.bind(this);
        this.DonateToEcosystemFund = this.DonateToEcosystemFund.bind(this);
    }
    RemoveMargin(request) {
        const data = exports.MsgRemoveMargin.encode(request).finish();
        const promise = this.rpc.request(this.service, "RemoveMargin", data);
        return promise.then((data) => exports.MsgRemoveMarginResponse.decode(minimal_1.default.Reader.create(data)));
    }
    AddMargin(request) {
        const data = exports.MsgAddMargin.encode(request).finish();
        const promise = this.rpc.request(this.service, "AddMargin", data);
        return promise.then((data) => exports.MsgAddMarginResponse.decode(minimal_1.default.Reader.create(data)));
    }
    MultiLiquidate(request) {
        const data = exports.MsgMultiLiquidate.encode(request).finish();
        const promise = this.rpc.request(this.service, "MultiLiquidate", data);
        return promise.then((data) => exports.MsgMultiLiquidateResponse.decode(minimal_1.default.Reader.create(data)));
    }
    MarketOrder(request) {
        const data = exports.MsgMarketOrder.encode(request).finish();
        const promise = this.rpc.request(this.service, "MarketOrder", data);
        return promise.then((data) => exports.MsgMarketOrderResponse.decode(minimal_1.default.Reader.create(data)));
    }
    ClosePosition(request) {
        const data = exports.MsgClosePosition.encode(request).finish();
        const promise = this.rpc.request(this.service, "ClosePosition", data);
        return promise.then((data) => exports.MsgClosePositionResponse.decode(minimal_1.default.Reader.create(data)));
    }
    PartialClose(request) {
        const data = exports.MsgPartialClose.encode(request).finish();
        const promise = this.rpc.request(this.service, "PartialClose", data);
        return promise.then((data) => exports.MsgPartialCloseResponse.decode(minimal_1.default.Reader.create(data)));
    }
    DonateToEcosystemFund(request) {
        const data = exports.MsgDonateToEcosystemFund.encode(request).finish();
        const promise = this.rpc.request(this.service, "DonateToEcosystemFund", data);
        return promise.then((data) => exports.MsgDonateToEcosystemFundResponse.decode(minimal_1.default.Reader.create(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=tx.js.map