"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgClientImpl = exports.MsgServiceName = exports.MsgSwapAssetsResponse = exports.MsgSwapAssets = exports.MsgExitPoolResponse = exports.MsgExitPool = exports.MsgJoinPoolResponse = exports.MsgJoinPool = exports.MsgCreatePoolResponse = exports.MsgCreatePool = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
const pool_1 = require("./pool");
exports.protobufPackage = "nibiru.spot.v1";
function createBaseMsgCreatePool() {
    return { creator: "", poolParams: undefined, poolAssets: [] };
}
exports.MsgCreatePool = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.poolParams !== undefined) {
            pool_1.PoolParams.encode(message.poolParams, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.poolAssets) {
            pool_1.PoolAsset.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.poolParams = pool_1.PoolParams.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.poolAssets.push(pool_1.PoolAsset.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? String(object.creator) : "",
            poolParams: isSet(object.poolParams)
                ? pool_1.PoolParams.fromJSON(object.poolParams)
                : undefined,
            poolAssets: Array.isArray(object === null || object === void 0 ? void 0 : object.poolAssets)
                ? object.poolAssets.map((e) => pool_1.PoolAsset.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.poolParams !== undefined &&
            (obj.poolParams = message.poolParams
                ? pool_1.PoolParams.toJSON(message.poolParams)
                : undefined);
        if (message.poolAssets) {
            obj.poolAssets = message.poolAssets.map((e) => e ? pool_1.PoolAsset.toJSON(e) : undefined);
        }
        else {
            obj.poolAssets = [];
        }
        return obj;
    },
    create(base) {
        return exports.MsgCreatePool.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgCreatePool();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.poolParams =
            object.poolParams !== undefined && object.poolParams !== null
                ? pool_1.PoolParams.fromPartial(object.poolParams)
                : undefined;
        message.poolAssets =
            ((_b = object.poolAssets) === null || _b === void 0 ? void 0 : _b.map((e) => pool_1.PoolAsset.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMsgCreatePoolResponse() {
    return { poolId: long_1.default.UZERO };
}
exports.MsgCreatePoolResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.poolId.isZero()) {
            writer.uint32(8).uint64(message.poolId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePoolResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.poolId = reader.uint64();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            poolId: isSet(object.poolId) ? long_1.default.fromValue(object.poolId) : long_1.default.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.poolId !== undefined &&
            (obj.poolId = (message.poolId || long_1.default.UZERO).toString());
        return obj;
    },
    create(base) {
        return exports.MsgCreatePoolResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseMsgCreatePoolResponse();
        message.poolId =
            object.poolId !== undefined && object.poolId !== null
                ? long_1.default.fromValue(object.poolId)
                : long_1.default.UZERO;
        return message;
    },
};
function createBaseMsgJoinPool() {
    return { sender: "", poolId: long_1.default.UZERO, tokensIn: [], useAllCoins: false };
}
exports.MsgJoinPool = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (!message.poolId.isZero()) {
            writer.uint32(16).uint64(message.poolId);
        }
        for (const v of message.tokensIn) {
            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.useAllCoins === true) {
            writer.uint32(32).bool(message.useAllCoins);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgJoinPool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.poolId = reader.uint64();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.tokensIn.push(coin_1.Coin.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.useAllCoins = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            poolId: isSet(object.poolId) ? long_1.default.fromValue(object.poolId) : long_1.default.UZERO,
            tokensIn: Array.isArray(object === null || object === void 0 ? void 0 : object.tokensIn)
                ? object.tokensIn.map((e) => coin_1.Coin.fromJSON(e))
                : [],
            useAllCoins: isSet(object.useAllCoins)
                ? Boolean(object.useAllCoins)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.poolId !== undefined &&
            (obj.poolId = (message.poolId || long_1.default.UZERO).toString());
        if (message.tokensIn) {
            obj.tokensIn = message.tokensIn.map((e) => e ? coin_1.Coin.toJSON(e) : undefined);
        }
        else {
            obj.tokensIn = [];
        }
        message.useAllCoins !== undefined && (obj.useAllCoins = message.useAllCoins);
        return obj;
    },
    create(base) {
        return exports.MsgJoinPool.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgJoinPool();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.poolId =
            object.poolId !== undefined && object.poolId !== null
                ? long_1.default.fromValue(object.poolId)
                : long_1.default.UZERO;
        message.tokensIn = ((_b = object.tokensIn) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.useAllCoins = (_c = object.useAllCoins) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
function createBaseMsgJoinPoolResponse() {
    return { pool: undefined, numPoolSharesOut: undefined, remainingCoins: [] };
}
exports.MsgJoinPoolResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pool !== undefined) {
            pool_1.Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        if (message.numPoolSharesOut !== undefined) {
            coin_1.Coin.encode(message.numPoolSharesOut, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.remainingCoins) {
            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgJoinPoolResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pool = pool_1.Pool.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.numPoolSharesOut = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.remainingCoins.push(coin_1.Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pool: isSet(object.pool) ? pool_1.Pool.fromJSON(object.pool) : undefined,
            numPoolSharesOut: isSet(object.numPoolSharesOut)
                ? coin_1.Coin.fromJSON(object.numPoolSharesOut)
                : undefined,
            remainingCoins: Array.isArray(object === null || object === void 0 ? void 0 : object.remainingCoins)
                ? object.remainingCoins.map((e) => coin_1.Coin.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.pool !== undefined &&
            (obj.pool = message.pool ? pool_1.Pool.toJSON(message.pool) : undefined);
        message.numPoolSharesOut !== undefined &&
            (obj.numPoolSharesOut = message.numPoolSharesOut
                ? coin_1.Coin.toJSON(message.numPoolSharesOut)
                : undefined);
        if (message.remainingCoins) {
            obj.remainingCoins = message.remainingCoins.map((e) => e ? coin_1.Coin.toJSON(e) : undefined);
        }
        else {
            obj.remainingCoins = [];
        }
        return obj;
    },
    create(base) {
        return exports.MsgJoinPoolResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgJoinPoolResponse();
        message.pool =
            object.pool !== undefined && object.pool !== null
                ? pool_1.Pool.fromPartial(object.pool)
                : undefined;
        message.numPoolSharesOut =
            object.numPoolSharesOut !== undefined && object.numPoolSharesOut !== null
                ? coin_1.Coin.fromPartial(object.numPoolSharesOut)
                : undefined;
        message.remainingCoins =
            ((_a = object.remainingCoins) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMsgExitPool() {
    return { sender: "", poolId: long_1.default.UZERO, poolShares: undefined };
}
exports.MsgExitPool = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (!message.poolId.isZero()) {
            writer.uint32(16).uint64(message.poolId);
        }
        if (message.poolShares !== undefined) {
            coin_1.Coin.encode(message.poolShares, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgExitPool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.poolId = reader.uint64();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.poolShares = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            poolId: isSet(object.poolId) ? long_1.default.fromValue(object.poolId) : long_1.default.UZERO,
            poolShares: isSet(object.poolShares)
                ? coin_1.Coin.fromJSON(object.poolShares)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.poolId !== undefined &&
            (obj.poolId = (message.poolId || long_1.default.UZERO).toString());
        message.poolShares !== undefined &&
            (obj.poolShares = message.poolShares
                ? coin_1.Coin.toJSON(message.poolShares)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.MsgExitPool.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgExitPool();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.poolId =
            object.poolId !== undefined && object.poolId !== null
                ? long_1.default.fromValue(object.poolId)
                : long_1.default.UZERO;
        message.poolShares =
            object.poolShares !== undefined && object.poolShares !== null
                ? coin_1.Coin.fromPartial(object.poolShares)
                : undefined;
        return message;
    },
};
function createBaseMsgExitPoolResponse() {
    return { tokensOut: [] };
}
exports.MsgExitPoolResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.tokensOut) {
            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgExitPoolResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.tokensOut.push(coin_1.Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tokensOut: Array.isArray(object === null || object === void 0 ? void 0 : object.tokensOut)
                ? object.tokensOut.map((e) => coin_1.Coin.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tokensOut) {
            obj.tokensOut = message.tokensOut.map((e) => e ? coin_1.Coin.toJSON(e) : undefined);
        }
        else {
            obj.tokensOut = [];
        }
        return obj;
    },
    create(base) {
        return exports.MsgExitPoolResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgExitPoolResponse();
        message.tokensOut = ((_a = object.tokensOut) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMsgSwapAssets() {
    return {
        sender: "",
        poolId: long_1.default.UZERO,
        tokenIn: undefined,
        tokenOutDenom: "",
    };
}
exports.MsgSwapAssets = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (!message.poolId.isZero()) {
            writer.uint32(16).uint64(message.poolId);
        }
        if (message.tokenIn !== undefined) {
            coin_1.Coin.encode(message.tokenIn, writer.uint32(26).fork()).ldelim();
        }
        if (message.tokenOutDenom !== "") {
            writer.uint32(34).string(message.tokenOutDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSwapAssets();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.poolId = reader.uint64();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.tokenIn = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.tokenOutDenom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            poolId: isSet(object.poolId) ? long_1.default.fromValue(object.poolId) : long_1.default.UZERO,
            tokenIn: isSet(object.tokenIn)
                ? coin_1.Coin.fromJSON(object.tokenIn)
                : undefined,
            tokenOutDenom: isSet(object.tokenOutDenom)
                ? String(object.tokenOutDenom)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.poolId !== undefined &&
            (obj.poolId = (message.poolId || long_1.default.UZERO).toString());
        message.tokenIn !== undefined &&
            (obj.tokenIn = message.tokenIn ? coin_1.Coin.toJSON(message.tokenIn) : undefined);
        message.tokenOutDenom !== undefined &&
            (obj.tokenOutDenom = message.tokenOutDenom);
        return obj;
    },
    create(base) {
        return exports.MsgSwapAssets.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSwapAssets();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.poolId =
            object.poolId !== undefined && object.poolId !== null
                ? long_1.default.fromValue(object.poolId)
                : long_1.default.UZERO;
        message.tokenIn =
            object.tokenIn !== undefined && object.tokenIn !== null
                ? coin_1.Coin.fromPartial(object.tokenIn)
                : undefined;
        message.tokenOutDenom = (_b = object.tokenOutDenom) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgSwapAssetsResponse() {
    return { tokenOut: undefined };
}
exports.MsgSwapAssetsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tokenOut !== undefined) {
            coin_1.Coin.encode(message.tokenOut, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSwapAssetsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.tokenOut = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tokenOut: isSet(object.tokenOut)
                ? coin_1.Coin.fromJSON(object.tokenOut)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.tokenOut !== undefined &&
            (obj.tokenOut = message.tokenOut
                ? coin_1.Coin.toJSON(message.tokenOut)
                : undefined);
        return obj;
    },
    create(base) {
        return exports.MsgSwapAssetsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseMsgSwapAssetsResponse();
        message.tokenOut =
            object.tokenOut !== undefined && object.tokenOut !== null
                ? coin_1.Coin.fromPartial(object.tokenOut)
                : undefined;
        return message;
    },
};
exports.MsgServiceName = "nibiru.spot.v1.Msg";
class MsgClientImpl {
    constructor(rpc, opts) {
        this.service = (opts === null || opts === void 0 ? void 0 : opts.service) || exports.MsgServiceName;
        this.rpc = rpc;
        this.CreatePool = this.CreatePool.bind(this);
        this.JoinPool = this.JoinPool.bind(this);
        this.ExitPool = this.ExitPool.bind(this);
        this.SwapAssets = this.SwapAssets.bind(this);
    }
    CreatePool(request) {
        const data = exports.MsgCreatePool.encode(request).finish();
        const promise = this.rpc.request(this.service, "CreatePool", data);
        return promise.then((data) => exports.MsgCreatePoolResponse.decode(minimal_1.default.Reader.create(data)));
    }
    JoinPool(request) {
        const data = exports.MsgJoinPool.encode(request).finish();
        const promise = this.rpc.request(this.service, "JoinPool", data);
        return promise.then((data) => exports.MsgJoinPoolResponse.decode(minimal_1.default.Reader.create(data)));
    }
    ExitPool(request) {
        const data = exports.MsgExitPool.encode(request).finish();
        const promise = this.rpc.request(this.service, "ExitPool", data);
        return promise.then((data) => exports.MsgExitPoolResponse.decode(minimal_1.default.Reader.create(data)));
    }
    SwapAssets(request) {
        const data = exports.MsgSwapAssets.encode(request).finish();
        const promise = this.rpc.request(this.service, "SwapAssets", data);
        return promise.then((data) => exports.MsgSwapAssetsResponse.decode(minimal_1.default.Reader.create(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=tx.js.map