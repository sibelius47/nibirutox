import Long from "long";
import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "nibiru.oracle.v1";
/**
 * MsgAggregateExchangeRatePrevote represents a message to submit
 * aggregate exchange rate prevote.
 */
export interface MsgAggregateExchangeRatePrevote {
    hash: string;
    /**
     * Feeder is the Bech32 address of the price feeder. A validator may
     * specify multiple price feeders by delegating them consent. The validator
     * address is also a valid feeder by default.
     */
    feeder: string;
    /** Validator is the Bech32 address to which the prevote will be credited. */
    validator: string;
}
/**
 * MsgAggregateExchangeRatePrevoteResponse defines the
 * Msg/AggregateExchangeRatePrevote response type.
 */
export interface MsgAggregateExchangeRatePrevoteResponse {
}
/**
 * MsgAggregateExchangeRateVote represents a message to submit
 * aggregate exchange rate vote.
 */
export interface MsgAggregateExchangeRateVote {
    salt: string;
    exchangeRates: string;
    /**
     * Feeder is the Bech32 address of the price feeder. A validator may
     * specify multiple price feeders by delegating them consent. The validator
     * address is also a valid feeder by default.
     */
    feeder: string;
    /** Validator is the Bech32 address to which the vote will be credited. */
    validator: string;
}
/**
 * MsgAggregateExchangeRateVoteResponse defines the
 * Msg/AggregateExchangeRateVote response type.
 */
export interface MsgAggregateExchangeRateVoteResponse {
}
/**
 * MsgDelegateFeedConsent represents a message to delegate oracle voting rights
 * to another address.
 */
export interface MsgDelegateFeedConsent {
    operator: string;
    delegate: string;
}
/**
 * MsgDelegateFeedConsentResponse defines the Msg/DelegateFeedConsent response
 * type.
 */
export interface MsgDelegateFeedConsentResponse {
}
export declare const MsgAggregateExchangeRatePrevote: {
    encode(message: MsgAggregateExchangeRatePrevote, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAggregateExchangeRatePrevote;
    fromJSON(object: any): MsgAggregateExchangeRatePrevote;
    toJSON(message: MsgAggregateExchangeRatePrevote): unknown;
    create<I extends {
        hash?: string | undefined;
        feeder?: string | undefined;
        validator?: string | undefined;
    } & {
        hash?: string | undefined;
        feeder?: string | undefined;
        validator?: string | undefined;
    } & { [K in Exclude<keyof I, keyof MsgAggregateExchangeRatePrevote>]: never; }>(base?: I | undefined): MsgAggregateExchangeRatePrevote;
    fromPartial<I_1 extends {
        hash?: string | undefined;
        feeder?: string | undefined;
        validator?: string | undefined;
    } & {
        hash?: string | undefined;
        feeder?: string | undefined;
        validator?: string | undefined;
    } & { [K_1 in Exclude<keyof I_1, keyof MsgAggregateExchangeRatePrevote>]: never; }>(object: I_1): MsgAggregateExchangeRatePrevote;
};
export declare const MsgAggregateExchangeRatePrevoteResponse: {
    encode(_: MsgAggregateExchangeRatePrevoteResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAggregateExchangeRatePrevoteResponse;
    fromJSON(_: any): MsgAggregateExchangeRatePrevoteResponse;
    toJSON(_: MsgAggregateExchangeRatePrevoteResponse): unknown;
    create<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(base?: I | undefined): MsgAggregateExchangeRatePrevoteResponse;
    fromPartial<I_1 extends {} & {} & { [K_1 in Exclude<keyof I_1, never>]: never; }>(_: I_1): MsgAggregateExchangeRatePrevoteResponse;
};
export declare const MsgAggregateExchangeRateVote: {
    encode(message: MsgAggregateExchangeRateVote, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAggregateExchangeRateVote;
    fromJSON(object: any): MsgAggregateExchangeRateVote;
    toJSON(message: MsgAggregateExchangeRateVote): unknown;
    create<I extends {
        salt?: string | undefined;
        exchangeRates?: string | undefined;
        feeder?: string | undefined;
        validator?: string | undefined;
    } & {
        salt?: string | undefined;
        exchangeRates?: string | undefined;
        feeder?: string | undefined;
        validator?: string | undefined;
    } & { [K in Exclude<keyof I, keyof MsgAggregateExchangeRateVote>]: never; }>(base?: I | undefined): MsgAggregateExchangeRateVote;
    fromPartial<I_1 extends {
        salt?: string | undefined;
        exchangeRates?: string | undefined;
        feeder?: string | undefined;
        validator?: string | undefined;
    } & {
        salt?: string | undefined;
        exchangeRates?: string | undefined;
        feeder?: string | undefined;
        validator?: string | undefined;
    } & { [K_1 in Exclude<keyof I_1, keyof MsgAggregateExchangeRateVote>]: never; }>(object: I_1): MsgAggregateExchangeRateVote;
};
export declare const MsgAggregateExchangeRateVoteResponse: {
    encode(_: MsgAggregateExchangeRateVoteResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAggregateExchangeRateVoteResponse;
    fromJSON(_: any): MsgAggregateExchangeRateVoteResponse;
    toJSON(_: MsgAggregateExchangeRateVoteResponse): unknown;
    create<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(base?: I | undefined): MsgAggregateExchangeRateVoteResponse;
    fromPartial<I_1 extends {} & {} & { [K_1 in Exclude<keyof I_1, never>]: never; }>(_: I_1): MsgAggregateExchangeRateVoteResponse;
};
export declare const MsgDelegateFeedConsent: {
    encode(message: MsgDelegateFeedConsent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDelegateFeedConsent;
    fromJSON(object: any): MsgDelegateFeedConsent;
    toJSON(message: MsgDelegateFeedConsent): unknown;
    create<I extends {
        operator?: string | undefined;
        delegate?: string | undefined;
    } & {
        operator?: string | undefined;
        delegate?: string | undefined;
    } & { [K in Exclude<keyof I, keyof MsgDelegateFeedConsent>]: never; }>(base?: I | undefined): MsgDelegateFeedConsent;
    fromPartial<I_1 extends {
        operator?: string | undefined;
        delegate?: string | undefined;
    } & {
        operator?: string | undefined;
        delegate?: string | undefined;
    } & { [K_1 in Exclude<keyof I_1, keyof MsgDelegateFeedConsent>]: never; }>(object: I_1): MsgDelegateFeedConsent;
};
export declare const MsgDelegateFeedConsentResponse: {
    encode(_: MsgDelegateFeedConsentResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDelegateFeedConsentResponse;
    fromJSON(_: any): MsgDelegateFeedConsentResponse;
    toJSON(_: MsgDelegateFeedConsentResponse): unknown;
    create<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(base?: I | undefined): MsgDelegateFeedConsentResponse;
    fromPartial<I_1 extends {} & {} & { [K_1 in Exclude<keyof I_1, never>]: never; }>(_: I_1): MsgDelegateFeedConsentResponse;
};
/** Msg defines the oracle Msg service. */
export interface Msg {
    /**
     * AggregateExchangeRatePrevote defines a method for submitting
     * aggregate exchange rate prevote
     */
    AggregateExchangeRatePrevote(request: MsgAggregateExchangeRatePrevote): Promise<MsgAggregateExchangeRatePrevoteResponse>;
    /**
     * AggregateExchangeRateVote defines a method for submitting
     * aggregate exchange rate vote
     */
    AggregateExchangeRateVote(request: MsgAggregateExchangeRateVote): Promise<MsgAggregateExchangeRateVoteResponse>;
    /**
     * DelegateFeedConsent defines a method for delegating oracle voting rights
     * to another address known as a price feeder.
     * See https://github.com/NibiruChain/pricefeeder.
     */
    DelegateFeedConsent(request: MsgDelegateFeedConsent): Promise<MsgDelegateFeedConsentResponse>;
}
export declare const MsgServiceName = "nibiru.oracle.v1.Msg";
export declare class MsgClientImpl implements Msg {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    AggregateExchangeRatePrevote(request: MsgAggregateExchangeRatePrevote): Promise<MsgAggregateExchangeRatePrevoteResponse>;
    AggregateExchangeRateVote(request: MsgAggregateExchangeRateVote): Promise<MsgAggregateExchangeRateVoteResponse>;
    DelegateFeedConsent(request: MsgDelegateFeedConsent): Promise<MsgDelegateFeedConsentResponse>;
}
interface Rpc {
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
declare type KeysOfUnion<T> = T extends T ? keyof T : never;
export declare type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
//# sourceMappingURL=tx.d.ts.map