"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgClientImpl = exports.MsgDonateToEcosystemFundResponse = exports.MsgDonateToEcosystemFund = exports.MsgClosePositionResponse = exports.MsgClosePosition = exports.MsgOpenPositionResponse = exports.MsgOpenPosition = exports.MsgMultiLiquidateResponse_LiquidationResponse = exports.MsgMultiLiquidateResponse = exports.MsgMultiLiquidate_Liquidation = exports.MsgMultiLiquidate = exports.MsgAddMarginResponse = exports.MsgAddMargin = exports.MsgRemoveMarginResponse = exports.MsgRemoveMargin = exports.protobufPackage = void 0;
/* eslint-disable */
const coin_1 = require("../../cosmos/base/v1beta1/coin");
const state_1 = require("./state");
const long_1 = __importDefault(require("long"));
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = "nibiru.perp.v1";
function createBaseMsgRemoveMargin() {
    return { sender: "", pair: "", margin: undefined };
}
exports.MsgRemoveMargin = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        if (message.margin !== undefined) {
            coin_1.Coin.encode(message.margin, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveMargin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.string();
                    break;
                case 2:
                    message.pair = reader.string();
                    break;
                case 3:
                    message.margin = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
            margin: isSet(object.margin) ? coin_1.Coin.fromJSON(object.margin) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.pair !== undefined && (obj.pair = message.pair);
        message.margin !== undefined &&
            (obj.margin = message.margin ? coin_1.Coin.toJSON(message.margin) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgRemoveMargin();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        message.margin =
            object.margin !== undefined && object.margin !== null
                ? coin_1.Coin.fromPartial(object.margin)
                : undefined;
        return message;
    },
};
function createBaseMsgRemoveMarginResponse() {
    return { marginOut: undefined, fundingPayment: "", position: undefined };
}
exports.MsgRemoveMarginResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.marginOut !== undefined) {
            coin_1.Coin.encode(message.marginOut, writer.uint32(10).fork()).ldelim();
        }
        if (message.fundingPayment !== "") {
            writer.uint32(18).string(message.fundingPayment);
        }
        if (message.position !== undefined) {
            state_1.Position.encode(message.position, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveMarginResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.marginOut = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.fundingPayment = reader.string();
                    break;
                case 3:
                    message.position = state_1.Position.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            marginOut: isSet(object.marginOut) ? coin_1.Coin.fromJSON(object.marginOut) : undefined,
            fundingPayment: isSet(object.fundingPayment) ? String(object.fundingPayment) : "",
            position: isSet(object.position) ? state_1.Position.fromJSON(object.position) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.marginOut !== undefined &&
            (obj.marginOut = message.marginOut ? coin_1.Coin.toJSON(message.marginOut) : undefined);
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.position !== undefined &&
            (obj.position = message.position ? state_1.Position.toJSON(message.position) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgRemoveMarginResponse();
        message.marginOut =
            object.marginOut !== undefined && object.marginOut !== null
                ? coin_1.Coin.fromPartial(object.marginOut)
                : undefined;
        message.fundingPayment = (_a = object.fundingPayment) !== null && _a !== void 0 ? _a : "";
        message.position =
            object.position !== undefined && object.position !== null
                ? state_1.Position.fromPartial(object.position)
                : undefined;
        return message;
    },
};
function createBaseMsgAddMargin() {
    return { sender: "", pair: "", margin: undefined };
}
exports.MsgAddMargin = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        if (message.margin !== undefined) {
            coin_1.Coin.encode(message.margin, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddMargin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.string();
                    break;
                case 2:
                    message.pair = reader.string();
                    break;
                case 3:
                    message.margin = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
            margin: isSet(object.margin) ? coin_1.Coin.fromJSON(object.margin) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.pair !== undefined && (obj.pair = message.pair);
        message.margin !== undefined &&
            (obj.margin = message.margin ? coin_1.Coin.toJSON(message.margin) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgAddMargin();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        message.margin =
            object.margin !== undefined && object.margin !== null
                ? coin_1.Coin.fromPartial(object.margin)
                : undefined;
        return message;
    },
};
function createBaseMsgAddMarginResponse() {
    return { fundingPayment: "", position: undefined };
}
exports.MsgAddMarginResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.fundingPayment !== "") {
            writer.uint32(10).string(message.fundingPayment);
        }
        if (message.position !== undefined) {
            state_1.Position.encode(message.position, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddMarginResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fundingPayment = reader.string();
                    break;
                case 2:
                    message.position = state_1.Position.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            fundingPayment: isSet(object.fundingPayment) ? String(object.fundingPayment) : "",
            position: isSet(object.position) ? state_1.Position.fromJSON(object.position) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.position !== undefined &&
            (obj.position = message.position ? state_1.Position.toJSON(message.position) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgAddMarginResponse();
        message.fundingPayment = (_a = object.fundingPayment) !== null && _a !== void 0 ? _a : "";
        message.position =
            object.position !== undefined && object.position !== null
                ? state_1.Position.fromPartial(object.position)
                : undefined;
        return message;
    },
};
function createBaseMsgMultiLiquidate() {
    return { sender: "", liquidations: [] };
}
exports.MsgMultiLiquidate = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        for (const v of message.liquidations) {
            exports.MsgMultiLiquidate_Liquidation.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiLiquidate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.string();
                    break;
                case 2:
                    message.liquidations.push(exports.MsgMultiLiquidate_Liquidation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            liquidations: Array.isArray(object === null || object === void 0 ? void 0 : object.liquidations)
                ? object.liquidations.map((e) => exports.MsgMultiLiquidate_Liquidation.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        if (message.liquidations) {
            obj.liquidations = message.liquidations.map((e) => e ? exports.MsgMultiLiquidate_Liquidation.toJSON(e) : undefined);
        }
        else {
            obj.liquidations = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgMultiLiquidate();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.liquidations =
            ((_b = object.liquidations) === null || _b === void 0 ? void 0 : _b.map((e) => exports.MsgMultiLiquidate_Liquidation.fromPartial(e))) ||
                [];
        return message;
    },
};
function createBaseMsgMultiLiquidate_Liquidation() {
    return { pair: "", trader: "" };
}
exports.MsgMultiLiquidate_Liquidation = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.trader !== "") {
            writer.uint32(18).string(message.trader);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiLiquidate_Liquidation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.trader = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            trader: isSet(object.trader) ? String(object.trader) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.trader !== undefined && (obj.trader = message.trader);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgMultiLiquidate_Liquidation();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.trader = (_b = object.trader) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgMultiLiquidateResponse() {
    return { liquidations: [] };
}
exports.MsgMultiLiquidateResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.liquidations) {
            exports.MsgMultiLiquidateResponse_LiquidationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiLiquidateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.liquidations.push(exports.MsgMultiLiquidateResponse_LiquidationResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            liquidations: Array.isArray(object === null || object === void 0 ? void 0 : object.liquidations)
                ? object.liquidations.map((e) => exports.MsgMultiLiquidateResponse_LiquidationResponse.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.liquidations) {
            obj.liquidations = message.liquidations.map((e) => e ? exports.MsgMultiLiquidateResponse_LiquidationResponse.toJSON(e) : undefined);
        }
        else {
            obj.liquidations = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgMultiLiquidateResponse();
        message.liquidations =
            ((_a = object.liquidations) === null || _a === void 0 ? void 0 : _a.map((e) => exports.MsgMultiLiquidateResponse_LiquidationResponse.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMsgMultiLiquidateResponse_LiquidationResponse() {
    return { success: false, error: "", liquidatorFee: undefined, perpEfFee: undefined };
}
exports.MsgMultiLiquidateResponse_LiquidationResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.success === true) {
            writer.uint32(8).bool(message.success);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        if (message.liquidatorFee !== undefined) {
            coin_1.Coin.encode(message.liquidatorFee, writer.uint32(26).fork()).ldelim();
        }
        if (message.perpEfFee !== undefined) {
            coin_1.Coin.encode(message.perpEfFee, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiLiquidateResponse_LiquidationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.success = reader.bool();
                    break;
                case 2:
                    message.error = reader.string();
                    break;
                case 3:
                    message.liquidatorFee = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.perpEfFee = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? Boolean(object.success) : false,
            error: isSet(object.error) ? String(object.error) : "",
            liquidatorFee: isSet(object.liquidatorFee)
                ? coin_1.Coin.fromJSON(object.liquidatorFee)
                : undefined,
            perpEfFee: isSet(object.perpEfFee) ? coin_1.Coin.fromJSON(object.perpEfFee) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.success !== undefined && (obj.success = message.success);
        message.error !== undefined && (obj.error = message.error);
        message.liquidatorFee !== undefined &&
            (obj.liquidatorFee = message.liquidatorFee
                ? coin_1.Coin.toJSON(message.liquidatorFee)
                : undefined);
        message.perpEfFee !== undefined &&
            (obj.perpEfFee = message.perpEfFee ? coin_1.Coin.toJSON(message.perpEfFee) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgMultiLiquidateResponse_LiquidationResponse();
        message.success = (_a = object.success) !== null && _a !== void 0 ? _a : false;
        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : "";
        message.liquidatorFee =
            object.liquidatorFee !== undefined && object.liquidatorFee !== null
                ? coin_1.Coin.fromPartial(object.liquidatorFee)
                : undefined;
        message.perpEfFee =
            object.perpEfFee !== undefined && object.perpEfFee !== null
                ? coin_1.Coin.fromPartial(object.perpEfFee)
                : undefined;
        return message;
    },
};
function createBaseMsgOpenPosition() {
    return {
        sender: "",
        pair: "",
        side: 0,
        quoteAssetAmount: "",
        leverage: "",
        baseAssetAmountLimit: "",
    };
}
exports.MsgOpenPosition = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        if (message.side !== 0) {
            writer.uint32(24).int32(message.side);
        }
        if (message.quoteAssetAmount !== "") {
            writer.uint32(34).string(message.quoteAssetAmount);
        }
        if (message.leverage !== "") {
            writer.uint32(42).string(message.leverage);
        }
        if (message.baseAssetAmountLimit !== "") {
            writer.uint32(50).string(message.baseAssetAmountLimit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOpenPosition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.string();
                    break;
                case 2:
                    message.pair = reader.string();
                    break;
                case 3:
                    message.side = reader.int32();
                    break;
                case 4:
                    message.quoteAssetAmount = reader.string();
                    break;
                case 5:
                    message.leverage = reader.string();
                    break;
                case 6:
                    message.baseAssetAmountLimit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
            side: isSet(object.side) ? (0, state_1.sideFromJSON)(object.side) : 0,
            quoteAssetAmount: isSet(object.quoteAssetAmount)
                ? String(object.quoteAssetAmount)
                : "",
            leverage: isSet(object.leverage) ? String(object.leverage) : "",
            baseAssetAmountLimit: isSet(object.baseAssetAmountLimit)
                ? String(object.baseAssetAmountLimit)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.pair !== undefined && (obj.pair = message.pair);
        message.side !== undefined && (obj.side = (0, state_1.sideToJSON)(message.side));
        message.quoteAssetAmount !== undefined &&
            (obj.quoteAssetAmount = message.quoteAssetAmount);
        message.leverage !== undefined && (obj.leverage = message.leverage);
        message.baseAssetAmountLimit !== undefined &&
            (obj.baseAssetAmountLimit = message.baseAssetAmountLimit);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMsgOpenPosition();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        message.side = (_c = object.side) !== null && _c !== void 0 ? _c : 0;
        message.quoteAssetAmount = (_d = object.quoteAssetAmount) !== null && _d !== void 0 ? _d : "";
        message.leverage = (_e = object.leverage) !== null && _e !== void 0 ? _e : "";
        message.baseAssetAmountLimit = (_f = object.baseAssetAmountLimit) !== null && _f !== void 0 ? _f : "";
        return message;
    },
};
function createBaseMsgOpenPositionResponse() {
    return {
        position: undefined,
        exchangedNotionalValue: "",
        exchangedPositionSize: "",
        fundingPayment: "",
        realizedPnl: "",
        unrealizedPnlAfter: "",
        marginToVault: "",
        positionNotional: "",
    };
}
exports.MsgOpenPositionResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.position !== undefined) {
            state_1.Position.encode(message.position, writer.uint32(10).fork()).ldelim();
        }
        if (message.exchangedNotionalValue !== "") {
            writer.uint32(18).string(message.exchangedNotionalValue);
        }
        if (message.exchangedPositionSize !== "") {
            writer.uint32(26).string(message.exchangedPositionSize);
        }
        if (message.fundingPayment !== "") {
            writer.uint32(34).string(message.fundingPayment);
        }
        if (message.realizedPnl !== "") {
            writer.uint32(42).string(message.realizedPnl);
        }
        if (message.unrealizedPnlAfter !== "") {
            writer.uint32(50).string(message.unrealizedPnlAfter);
        }
        if (message.marginToVault !== "") {
            writer.uint32(58).string(message.marginToVault);
        }
        if (message.positionNotional !== "") {
            writer.uint32(66).string(message.positionNotional);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOpenPositionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.position = state_1.Position.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.exchangedNotionalValue = reader.string();
                    break;
                case 3:
                    message.exchangedPositionSize = reader.string();
                    break;
                case 4:
                    message.fundingPayment = reader.string();
                    break;
                case 5:
                    message.realizedPnl = reader.string();
                    break;
                case 6:
                    message.unrealizedPnlAfter = reader.string();
                    break;
                case 7:
                    message.marginToVault = reader.string();
                    break;
                case 8:
                    message.positionNotional = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            position: isSet(object.position) ? state_1.Position.fromJSON(object.position) : undefined,
            exchangedNotionalValue: isSet(object.exchangedNotionalValue)
                ? String(object.exchangedNotionalValue)
                : "",
            exchangedPositionSize: isSet(object.exchangedPositionSize)
                ? String(object.exchangedPositionSize)
                : "",
            fundingPayment: isSet(object.fundingPayment) ? String(object.fundingPayment) : "",
            realizedPnl: isSet(object.realizedPnl) ? String(object.realizedPnl) : "",
            unrealizedPnlAfter: isSet(object.unrealizedPnlAfter)
                ? String(object.unrealizedPnlAfter)
                : "",
            marginToVault: isSet(object.marginToVault) ? String(object.marginToVault) : "",
            positionNotional: isSet(object.positionNotional)
                ? String(object.positionNotional)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.position !== undefined &&
            (obj.position = message.position ? state_1.Position.toJSON(message.position) : undefined);
        message.exchangedNotionalValue !== undefined &&
            (obj.exchangedNotionalValue = message.exchangedNotionalValue);
        message.exchangedPositionSize !== undefined &&
            (obj.exchangedPositionSize = message.exchangedPositionSize);
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.realizedPnl !== undefined && (obj.realizedPnl = message.realizedPnl);
        message.unrealizedPnlAfter !== undefined &&
            (obj.unrealizedPnlAfter = message.unrealizedPnlAfter);
        message.marginToVault !== undefined && (obj.marginToVault = message.marginToVault);
        message.positionNotional !== undefined &&
            (obj.positionNotional = message.positionNotional);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseMsgOpenPositionResponse();
        message.position =
            object.position !== undefined && object.position !== null
                ? state_1.Position.fromPartial(object.position)
                : undefined;
        message.exchangedNotionalValue = (_a = object.exchangedNotionalValue) !== null && _a !== void 0 ? _a : "";
        message.exchangedPositionSize = (_b = object.exchangedPositionSize) !== null && _b !== void 0 ? _b : "";
        message.fundingPayment = (_c = object.fundingPayment) !== null && _c !== void 0 ? _c : "";
        message.realizedPnl = (_d = object.realizedPnl) !== null && _d !== void 0 ? _d : "";
        message.unrealizedPnlAfter = (_e = object.unrealizedPnlAfter) !== null && _e !== void 0 ? _e : "";
        message.marginToVault = (_f = object.marginToVault) !== null && _f !== void 0 ? _f : "";
        message.positionNotional = (_g = object.positionNotional) !== null && _g !== void 0 ? _g : "";
        return message;
    },
};
function createBaseMsgClosePosition() {
    return { sender: "", pair: "" };
}
exports.MsgClosePosition = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClosePosition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.string();
                    break;
                case 2:
                    message.pair = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.pair !== undefined && (obj.pair = message.pair);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgClosePosition();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgClosePositionResponse() {
    return {
        exchangedNotionalValue: "",
        exchangedPositionSize: "",
        fundingPayment: "",
        realizedPnl: "",
        marginToTrader: "",
    };
}
exports.MsgClosePositionResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.exchangedNotionalValue !== "") {
            writer.uint32(10).string(message.exchangedNotionalValue);
        }
        if (message.exchangedPositionSize !== "") {
            writer.uint32(18).string(message.exchangedPositionSize);
        }
        if (message.fundingPayment !== "") {
            writer.uint32(26).string(message.fundingPayment);
        }
        if (message.realizedPnl !== "") {
            writer.uint32(34).string(message.realizedPnl);
        }
        if (message.marginToTrader !== "") {
            writer.uint32(58).string(message.marginToTrader);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClosePositionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exchangedNotionalValue = reader.string();
                    break;
                case 2:
                    message.exchangedPositionSize = reader.string();
                    break;
                case 3:
                    message.fundingPayment = reader.string();
                    break;
                case 4:
                    message.realizedPnl = reader.string();
                    break;
                case 7:
                    message.marginToTrader = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            exchangedNotionalValue: isSet(object.exchangedNotionalValue)
                ? String(object.exchangedNotionalValue)
                : "",
            exchangedPositionSize: isSet(object.exchangedPositionSize)
                ? String(object.exchangedPositionSize)
                : "",
            fundingPayment: isSet(object.fundingPayment) ? String(object.fundingPayment) : "",
            realizedPnl: isSet(object.realizedPnl) ? String(object.realizedPnl) : "",
            marginToTrader: isSet(object.marginToTrader) ? String(object.marginToTrader) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.exchangedNotionalValue !== undefined &&
            (obj.exchangedNotionalValue = message.exchangedNotionalValue);
        message.exchangedPositionSize !== undefined &&
            (obj.exchangedPositionSize = message.exchangedPositionSize);
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.realizedPnl !== undefined && (obj.realizedPnl = message.realizedPnl);
        message.marginToTrader !== undefined &&
            (obj.marginToTrader = message.marginToTrader);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgClosePositionResponse();
        message.exchangedNotionalValue = (_a = object.exchangedNotionalValue) !== null && _a !== void 0 ? _a : "";
        message.exchangedPositionSize = (_b = object.exchangedPositionSize) !== null && _b !== void 0 ? _b : "";
        message.fundingPayment = (_c = object.fundingPayment) !== null && _c !== void 0 ? _c : "";
        message.realizedPnl = (_d = object.realizedPnl) !== null && _d !== void 0 ? _d : "";
        message.marginToTrader = (_e = object.marginToTrader) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseMsgDonateToEcosystemFund() {
    return { sender: "", donation: undefined };
}
exports.MsgDonateToEcosystemFund = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.donation !== undefined) {
            coin_1.Coin.encode(message.donation, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDonateToEcosystemFund();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.string();
                    break;
                case 2:
                    message.donation = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? String(object.sender) : "",
            donation: isSet(object.donation) ? coin_1.Coin.fromJSON(object.donation) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender);
        message.donation !== undefined &&
            (obj.donation = message.donation ? coin_1.Coin.toJSON(message.donation) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgDonateToEcosystemFund();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.donation =
            object.donation !== undefined && object.donation !== null
                ? coin_1.Coin.fromPartial(object.donation)
                : undefined;
        return message;
    },
};
function createBaseMsgDonateToEcosystemFundResponse() {
    return {};
}
exports.MsgDonateToEcosystemFundResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDonateToEcosystemFundResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgDonateToEcosystemFundResponse();
        return message;
    },
};
class MsgClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.RemoveMargin = this.RemoveMargin.bind(this);
        this.AddMargin = this.AddMargin.bind(this);
        this.MultiLiquidate = this.MultiLiquidate.bind(this);
        this.OpenPosition = this.OpenPosition.bind(this);
        this.ClosePosition = this.ClosePosition.bind(this);
        this.DonateToEcosystemFund = this.DonateToEcosystemFund.bind(this);
    }
    RemoveMargin(request) {
        const data = exports.MsgRemoveMargin.encode(request).finish();
        const promise = this.rpc.request("nibiru.perp.v1.Msg", "RemoveMargin", data);
        return promise.then((data) => exports.MsgRemoveMarginResponse.decode(new _m0.Reader(data)));
    }
    AddMargin(request) {
        const data = exports.MsgAddMargin.encode(request).finish();
        const promise = this.rpc.request("nibiru.perp.v1.Msg", "AddMargin", data);
        return promise.then((data) => exports.MsgAddMarginResponse.decode(new _m0.Reader(data)));
    }
    MultiLiquidate(request) {
        const data = exports.MsgMultiLiquidate.encode(request).finish();
        const promise = this.rpc.request("nibiru.perp.v1.Msg", "MultiLiquidate", data);
        return promise.then((data) => exports.MsgMultiLiquidateResponse.decode(new _m0.Reader(data)));
    }
    OpenPosition(request) {
        const data = exports.MsgOpenPosition.encode(request).finish();
        const promise = this.rpc.request("nibiru.perp.v1.Msg", "OpenPosition", data);
        return promise.then((data) => exports.MsgOpenPositionResponse.decode(new _m0.Reader(data)));
    }
    ClosePosition(request) {
        const data = exports.MsgClosePosition.encode(request).finish();
        const promise = this.rpc.request("nibiru.perp.v1.Msg", "ClosePosition", data);
        return promise.then((data) => exports.MsgClosePositionResponse.decode(new _m0.Reader(data)));
    }
    DonateToEcosystemFund(request) {
        const data = exports.MsgDonateToEcosystemFund.encode(request).finish();
        const promise = this.rpc.request("nibiru.perp.v1.Msg", "DonateToEcosystemFund", data);
        return promise.then((data) => exports.MsgDonateToEcosystemFundResponse.decode(new _m0.Reader(data)));
    }
}
exports.MsgClientImpl = MsgClientImpl;
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=tx.js.map