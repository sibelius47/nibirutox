import { Coin } from "../../cosmos/base/v1beta1/coin";
import Long from "long";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "nibiru.perp.v1";
/**
 * Emitted when a position changes.
 * TODO: Is there a way to split this into different events without creating too much complexity?
 */
export interface PositionChangedEvent {
    /** identifier of the corresponding virtual pool for the position */
    pair: string;
    /** owner of the position. */
    traderAddress: string;
    /** Amount of collateral (quote units) backing the position after the change. */
    margin?: Coin;
    /**
     * Position notional (quote units) after the change. In general,
     * 'notional = baseAmount * priceQuotePerBase', where size is the baseAmount.
     */
    positionNotional: string;
    /**
     * Exchanged size is the magnitude of the change to position size (base units).
     * The size is a signed quantity expressing how much exposure a position has in
     * base units of the pair.
     */
    exchangedSize: string;
    /**
     * Exchanged notional is the value of the exchanged size in quote units.
     * exchangedNotional = posBefore.OpenNotional + (direction * realizedPnl),
     * where 'posBefore' is the position before the change, and
     * direction is 1 if posBefore.Size > 0 or -1 if posBefore.Size < 0,
     */
    exchangedNotional: string;
    /** Transaction fee paid. A "taker" fee. */
    transactionFee?: Coin;
    /** Position size after the change. */
    positionSize: string;
    /** realize profits and losses after the change */
    realizedPnl: string;
    /** unrealized profits and losses after the change */
    unrealizedPnlAfter: string;
    /**
     * Amount of bad debt cleared by the PerpEF during the change.
     * Bad debt is negative net margin past the liquidation point of a position.
     */
    badDebt?: Coin;
    /**
     * Mark price, synonymous with mark price in this context, is the quotient of
     * the quote reserves and base reserves
     */
    markPrice: string;
    /**
     * A funding payment made or received by the trader on the current position.
     * 'fundingPayment' is positive if 'owner' is the sender and negative if 'owner'
     * is the receiver of the payment. Its magnitude is abs(vSize * fundingRate).
     * Funding payments act to converge the mark price (vPrice) and index price
     * (average price on major exchanges).
     */
    fundingPayment: string;
    /** The block number at which this position was changed. */
    blockHeight: Long;
    /** The block time in unix milliseconds at which this position was changed. */
    blockTimeMs: Long;
}
/** Emitted when a position is liquidated. */
export interface PositionLiquidatedEvent {
    /** identifier of the corresponding virtual pool for the position */
    pair: string;
    /** owner of the position. */
    traderAddress: string;
    /** margin * leverage * vPrice. 'notional' is the virtual size times  the virtual price on 'vpool'. */
    exchangedQuoteAmount: string;
    /** virtual amount of base assets for the position, which would be margin * leverage * priceBasePerQuote. */
    exchangedPositionSize: string;
    /** Address of the account that executed the tx. */
    liquidatorAddress: string;
    /** Commission (in margin units) received by 'liquidator'. */
    feeToLiquidator?: Coin;
    /** Commission (in margin units) given to the ecosystem fund. */
    feeToEcosystemFund?: Coin;
    /** Bad debt (margin units) cleared by the PerpEF during the tx. Bad debt is negative net margin past the liquidation point of a position. */
    badDebt?: Coin;
    /** Remaining margin in the position after liquidation */
    margin?: Coin;
    /** Remaining position notional in the position after liquidation */
    positionNotional: string;
    /** Remaining position size in the position after liquidation */
    positionSize: string;
    /** Unrealized PnL in the position after liquidation */
    unrealizedPnl: string;
    /** Spot price of the vAMM after liquidation */
    markPrice: string;
    /** The block number at which this liquidation occured. */
    blockHeight: Long;
    /** The unix timestamp in milliseconds at which this liquidation occured. */
    blockTimeMs: Long;
}
/** Emitted when a position is settled. */
export interface PositionSettledEvent {
    /** Identifier for the virtual pool of the position. */
    pair: string;
    /** Owner of the position. */
    traderAddress: string;
    /** Settled coin as dictated by the settlement price of the vpool. */
    settledCoins: Coin[];
}
/** Emitted when a new funding rate is calculated. */
export interface FundingRateChangedEvent {
    /** The pair for which the funding rate was calculated. */
    pair: string;
    /** The mark price of the pair. */
    markPrice: string;
    /** The oracle index price of the pair. */
    indexPrice: string;
    /** The latest funding rate. */
    latestFundingRate: string;
    /** The latest premium fraction just calculated. */
    latestPremiumFraction: string;
    /**
     * The latest cumulative premium fraction.
     * The funding payment a position will pay is the difference between this value
     * and the latest cumulative premium fraction on the position, multiplied by the position size.
     */
    cumulativePremiumFraction: string;
    /** The block number at which the funding rate was calculated. */
    blockHeight: Long;
    /** The block time in unix milliseconds at which the funding rate was calculated. */
    blockTimeMs: Long;
}
/** Emitted when liquidation fails. */
export interface LiquidationFailedEvent {
    /** The pair for which we are trying to liquidate. */
    pair: string;
    /** owner of the position. */
    trader: string;
    /** Address of the account that executed the tx. */
    liquidator: string;
    /** Reason for the liquidation failure. */
    reason: LiquidationFailedEvent_LiquidationFailedReason;
}
export declare enum LiquidationFailedEvent_LiquidationFailedReason {
    UNSPECIFIED = 0,
    /** POSITION_HEALTHY - the position is healthy and does not need to be liquidated. */
    POSITION_HEALTHY = 1,
    /** NONEXISTENT_PAIR - the pair does not exist. */
    NONEXISTENT_PAIR = 2,
    /** NONEXISTENT_POSITION - the position does not exist. */
    NONEXISTENT_POSITION = 3,
    UNRECOGNIZED = -1
}
export declare function liquidationFailedEvent_LiquidationFailedReasonFromJSON(object: any): LiquidationFailedEvent_LiquidationFailedReason;
export declare function liquidationFailedEvent_LiquidationFailedReasonToJSON(object: LiquidationFailedEvent_LiquidationFailedReason): string;
export interface MetricsEvent {
    pair: string;
    /** Sum of all active position sizes for the pair. */
    netSize: string;
    /** Total notional volume for the pair. */
    volumeQuote: string;
    /** Total size volume for the pair. */
    volumeBase: string;
    /** The block number at which metrics were generated. */
    blockHeight: Long;
    /** The block time in unix milliseconds at which metrics were generated. */
    blockTimeMs: Long;
}
export declare const PositionChangedEvent: {
    encode(message: PositionChangedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PositionChangedEvent;
    fromJSON(object: any): PositionChangedEvent;
    toJSON(message: PositionChangedEvent): unknown;
    fromPartial<I extends {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        margin?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        positionNotional?: string | undefined;
        exchangedSize?: string | undefined;
        exchangedNotional?: string | undefined;
        transactionFee?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        positionSize?: string | undefined;
        realizedPnl?: string | undefined;
        unrealizedPnlAfter?: string | undefined;
        badDebt?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        markPrice?: string | undefined;
        fundingPayment?: string | undefined;
        blockHeight?: string | number | Long.Long | undefined;
        blockTimeMs?: string | number | Long.Long | undefined;
    } & {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        margin?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["margin"], keyof Coin>, never>) | undefined;
        positionNotional?: string | undefined;
        exchangedSize?: string | undefined;
        exchangedNotional?: string | undefined;
        transactionFee?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["transactionFee"], keyof Coin>, never>) | undefined;
        positionSize?: string | undefined;
        realizedPnl?: string | undefined;
        unrealizedPnlAfter?: string | undefined;
        badDebt?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["badDebt"], keyof Coin>, never>) | undefined;
        markPrice?: string | undefined;
        fundingPayment?: string | undefined;
        blockHeight?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockHeight"], keyof Long.Long>, never>) | undefined;
        blockTimeMs?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockTimeMs"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof PositionChangedEvent>, never>>(object: I): PositionChangedEvent;
};
export declare const PositionLiquidatedEvent: {
    encode(message: PositionLiquidatedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PositionLiquidatedEvent;
    fromJSON(object: any): PositionLiquidatedEvent;
    toJSON(message: PositionLiquidatedEvent): unknown;
    fromPartial<I extends {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        exchangedQuoteAmount?: string | undefined;
        exchangedPositionSize?: string | undefined;
        liquidatorAddress?: string | undefined;
        feeToLiquidator?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        feeToEcosystemFund?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        badDebt?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        margin?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        positionNotional?: string | undefined;
        positionSize?: string | undefined;
        unrealizedPnl?: string | undefined;
        markPrice?: string | undefined;
        blockHeight?: string | number | Long.Long | undefined;
        blockTimeMs?: string | number | Long.Long | undefined;
    } & {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        exchangedQuoteAmount?: string | undefined;
        exchangedPositionSize?: string | undefined;
        liquidatorAddress?: string | undefined;
        feeToLiquidator?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["feeToLiquidator"], keyof Coin>, never>) | undefined;
        feeToEcosystemFund?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["feeToEcosystemFund"], keyof Coin>, never>) | undefined;
        badDebt?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["badDebt"], keyof Coin>, never>) | undefined;
        margin?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["margin"], keyof Coin>, never>) | undefined;
        positionNotional?: string | undefined;
        positionSize?: string | undefined;
        unrealizedPnl?: string | undefined;
        markPrice?: string | undefined;
        blockHeight?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockHeight"], keyof Long.Long>, never>) | undefined;
        blockTimeMs?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockTimeMs"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof PositionLiquidatedEvent>, never>>(object: I): PositionLiquidatedEvent;
};
export declare const PositionSettledEvent: {
    encode(message: PositionSettledEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PositionSettledEvent;
    fromJSON(object: any): PositionSettledEvent;
    toJSON(message: PositionSettledEvent): unknown;
    fromPartial<I extends {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        settledCoins?: {
            denom?: string | undefined;
            amount?: string | undefined;
        }[] | undefined;
    } & {
        pair?: string | undefined;
        traderAddress?: string | undefined;
        settledCoins?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        }[] & ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["settledCoins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["settledCoins"], keyof {
            denom?: string | undefined;
            amount?: string | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof PositionSettledEvent>, never>>(object: I): PositionSettledEvent;
};
export declare const FundingRateChangedEvent: {
    encode(message: FundingRateChangedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FundingRateChangedEvent;
    fromJSON(object: any): FundingRateChangedEvent;
    toJSON(message: FundingRateChangedEvent): unknown;
    fromPartial<I extends {
        pair?: string | undefined;
        markPrice?: string | undefined;
        indexPrice?: string | undefined;
        latestFundingRate?: string | undefined;
        latestPremiumFraction?: string | undefined;
        cumulativePremiumFraction?: string | undefined;
        blockHeight?: string | number | Long.Long | undefined;
        blockTimeMs?: string | number | Long.Long | undefined;
    } & {
        pair?: string | undefined;
        markPrice?: string | undefined;
        indexPrice?: string | undefined;
        latestFundingRate?: string | undefined;
        latestPremiumFraction?: string | undefined;
        cumulativePremiumFraction?: string | undefined;
        blockHeight?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockHeight"], keyof Long.Long>, never>) | undefined;
        blockTimeMs?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockTimeMs"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof FundingRateChangedEvent>, never>>(object: I): FundingRateChangedEvent;
};
export declare const LiquidationFailedEvent: {
    encode(message: LiquidationFailedEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LiquidationFailedEvent;
    fromJSON(object: any): LiquidationFailedEvent;
    toJSON(message: LiquidationFailedEvent): unknown;
    fromPartial<I extends {
        pair?: string | undefined;
        trader?: string | undefined;
        liquidator?: string | undefined;
        reason?: LiquidationFailedEvent_LiquidationFailedReason | undefined;
    } & {
        pair?: string | undefined;
        trader?: string | undefined;
        liquidator?: string | undefined;
        reason?: LiquidationFailedEvent_LiquidationFailedReason | undefined;
    } & Record<Exclude<keyof I, keyof LiquidationFailedEvent>, never>>(object: I): LiquidationFailedEvent;
};
export declare const MetricsEvent: {
    encode(message: MetricsEvent, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MetricsEvent;
    fromJSON(object: any): MetricsEvent;
    toJSON(message: MetricsEvent): unknown;
    fromPartial<I extends {
        pair?: string | undefined;
        netSize?: string | undefined;
        volumeQuote?: string | undefined;
        volumeBase?: string | undefined;
        blockHeight?: string | number | Long.Long | undefined;
        blockTimeMs?: string | number | Long.Long | undefined;
    } & {
        pair?: string | undefined;
        netSize?: string | undefined;
        volumeQuote?: string | undefined;
        volumeBase?: string | undefined;
        blockHeight?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockHeight"], keyof Long.Long>, never>) | undefined;
        blockTimeMs?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockTimeMs"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MetricsEvent>, never>>(object: I): MetricsEvent;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
declare type KeysOfUnion<T> = T extends T ? keyof T : never;
export declare type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
//# sourceMappingURL=event.d.ts.map