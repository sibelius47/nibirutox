"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Metrics = exports.LiquidateResp = exports.PositionResp = exports.PrepaidBadDebt = exports.PairMetadata = exports.Position = exports.Params = exports.marginCalculationPriceOptionToJSON = exports.marginCalculationPriceOptionFromJSON = exports.MarginCalculationPriceOption = exports.pnLPreferenceOptionToJSON = exports.pnLPreferenceOptionFromJSON = exports.PnLPreferenceOption = exports.pnLCalcOptionToJSON = exports.pnLCalcOptionFromJSON = exports.PnLCalcOption = exports.sideToJSON = exports.sideFromJSON = exports.Side = exports.protobufPackage = void 0;
/* eslint-disable */
const duration_1 = require("../../google/protobuf/duration");
const long_1 = __importDefault(require("long"));
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = "nibiru.perp.v1";
var Side;
(function (Side) {
    Side[Side["SIDE_UNSPECIFIED"] = 0] = "SIDE_UNSPECIFIED";
    Side[Side["BUY"] = 1] = "BUY";
    Side[Side["SELL"] = 2] = "SELL";
    Side[Side["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Side = exports.Side || (exports.Side = {}));
function sideFromJSON(object) {
    switch (object) {
        case 0:
        case "SIDE_UNSPECIFIED":
            return Side.SIDE_UNSPECIFIED;
        case 1:
        case "BUY":
            return Side.BUY;
        case 2:
        case "SELL":
            return Side.SELL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Side.UNRECOGNIZED;
    }
}
exports.sideFromJSON = sideFromJSON;
function sideToJSON(object) {
    switch (object) {
        case Side.SIDE_UNSPECIFIED:
            return "SIDE_UNSPECIFIED";
        case Side.BUY:
            return "BUY";
        case Side.SELL:
            return "SELL";
        case Side.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.sideToJSON = sideToJSON;
var PnLCalcOption;
(function (PnLCalcOption) {
    PnLCalcOption[PnLCalcOption["PNL_CALC_OPTION_UNSPECIFIED"] = 0] = "PNL_CALC_OPTION_UNSPECIFIED";
    PnLCalcOption[PnLCalcOption["SPOT_PRICE"] = 1] = "SPOT_PRICE";
    PnLCalcOption[PnLCalcOption["TWAP"] = 2] = "TWAP";
    PnLCalcOption[PnLCalcOption["ORACLE"] = 3] = "ORACLE";
    PnLCalcOption[PnLCalcOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PnLCalcOption = exports.PnLCalcOption || (exports.PnLCalcOption = {}));
function pnLCalcOptionFromJSON(object) {
    switch (object) {
        case 0:
        case "PNL_CALC_OPTION_UNSPECIFIED":
            return PnLCalcOption.PNL_CALC_OPTION_UNSPECIFIED;
        case 1:
        case "SPOT_PRICE":
            return PnLCalcOption.SPOT_PRICE;
        case 2:
        case "TWAP":
            return PnLCalcOption.TWAP;
        case 3:
        case "ORACLE":
            return PnLCalcOption.ORACLE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PnLCalcOption.UNRECOGNIZED;
    }
}
exports.pnLCalcOptionFromJSON = pnLCalcOptionFromJSON;
function pnLCalcOptionToJSON(object) {
    switch (object) {
        case PnLCalcOption.PNL_CALC_OPTION_UNSPECIFIED:
            return "PNL_CALC_OPTION_UNSPECIFIED";
        case PnLCalcOption.SPOT_PRICE:
            return "SPOT_PRICE";
        case PnLCalcOption.TWAP:
            return "TWAP";
        case PnLCalcOption.ORACLE:
            return "ORACLE";
        case PnLCalcOption.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.pnLCalcOptionToJSON = pnLCalcOptionToJSON;
var PnLPreferenceOption;
(function (PnLPreferenceOption) {
    PnLPreferenceOption[PnLPreferenceOption["PNL_PREFERENCE_UNSPECIFIED"] = 0] = "PNL_PREFERENCE_UNSPECIFIED";
    PnLPreferenceOption[PnLPreferenceOption["MAX"] = 1] = "MAX";
    PnLPreferenceOption[PnLPreferenceOption["MIN"] = 2] = "MIN";
    PnLPreferenceOption[PnLPreferenceOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PnLPreferenceOption = exports.PnLPreferenceOption || (exports.PnLPreferenceOption = {}));
function pnLPreferenceOptionFromJSON(object) {
    switch (object) {
        case 0:
        case "PNL_PREFERENCE_UNSPECIFIED":
            return PnLPreferenceOption.PNL_PREFERENCE_UNSPECIFIED;
        case 1:
        case "MAX":
            return PnLPreferenceOption.MAX;
        case 2:
        case "MIN":
            return PnLPreferenceOption.MIN;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PnLPreferenceOption.UNRECOGNIZED;
    }
}
exports.pnLPreferenceOptionFromJSON = pnLPreferenceOptionFromJSON;
function pnLPreferenceOptionToJSON(object) {
    switch (object) {
        case PnLPreferenceOption.PNL_PREFERENCE_UNSPECIFIED:
            return "PNL_PREFERENCE_UNSPECIFIED";
        case PnLPreferenceOption.MAX:
            return "MAX";
        case PnLPreferenceOption.MIN:
            return "MIN";
        case PnLPreferenceOption.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.pnLPreferenceOptionToJSON = pnLPreferenceOptionToJSON;
var MarginCalculationPriceOption;
(function (MarginCalculationPriceOption) {
    MarginCalculationPriceOption[MarginCalculationPriceOption["MARGIN_CALCULATION_PRICE_OPTION_UNSPECIFIED"] = 0] = "MARGIN_CALCULATION_PRICE_OPTION_UNSPECIFIED";
    MarginCalculationPriceOption[MarginCalculationPriceOption["SPOT"] = 1] = "SPOT";
    MarginCalculationPriceOption[MarginCalculationPriceOption["INDEX"] = 2] = "INDEX";
    MarginCalculationPriceOption[MarginCalculationPriceOption["MAX_PNL"] = 3] = "MAX_PNL";
    MarginCalculationPriceOption[MarginCalculationPriceOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MarginCalculationPriceOption = exports.MarginCalculationPriceOption || (exports.MarginCalculationPriceOption = {}));
function marginCalculationPriceOptionFromJSON(object) {
    switch (object) {
        case 0:
        case "MARGIN_CALCULATION_PRICE_OPTION_UNSPECIFIED":
            return MarginCalculationPriceOption.MARGIN_CALCULATION_PRICE_OPTION_UNSPECIFIED;
        case 1:
        case "SPOT":
            return MarginCalculationPriceOption.SPOT;
        case 2:
        case "INDEX":
            return MarginCalculationPriceOption.INDEX;
        case 3:
        case "MAX_PNL":
            return MarginCalculationPriceOption.MAX_PNL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return MarginCalculationPriceOption.UNRECOGNIZED;
    }
}
exports.marginCalculationPriceOptionFromJSON = marginCalculationPriceOptionFromJSON;
function marginCalculationPriceOptionToJSON(object) {
    switch (object) {
        case MarginCalculationPriceOption.MARGIN_CALCULATION_PRICE_OPTION_UNSPECIFIED:
            return "MARGIN_CALCULATION_PRICE_OPTION_UNSPECIFIED";
        case MarginCalculationPriceOption.SPOT:
            return "SPOT";
        case MarginCalculationPriceOption.INDEX:
            return "INDEX";
        case MarginCalculationPriceOption.MAX_PNL:
            return "MAX_PNL";
        case MarginCalculationPriceOption.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.marginCalculationPriceOptionToJSON = marginCalculationPriceOptionToJSON;
function createBaseParams() {
    return {
        stopped: false,
        feePoolFeeRatio: "",
        ecosystemFundFeeRatio: "",
        liquidationFeeRatio: "",
        partialLiquidationRatio: "",
        fundingRateInterval: "",
        twapLookbackWindow: undefined,
        whitelistedLiquidators: [],
    };
}
exports.Params = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.stopped === true) {
            writer.uint32(8).bool(message.stopped);
        }
        if (message.feePoolFeeRatio !== "") {
            writer.uint32(26).string(message.feePoolFeeRatio);
        }
        if (message.ecosystemFundFeeRatio !== "") {
            writer.uint32(34).string(message.ecosystemFundFeeRatio);
        }
        if (message.liquidationFeeRatio !== "") {
            writer.uint32(42).string(message.liquidationFeeRatio);
        }
        if (message.partialLiquidationRatio !== "") {
            writer.uint32(50).string(message.partialLiquidationRatio);
        }
        if (message.fundingRateInterval !== "") {
            writer.uint32(58).string(message.fundingRateInterval);
        }
        if (message.twapLookbackWindow !== undefined) {
            duration_1.Duration.encode(message.twapLookbackWindow, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.whitelistedLiquidators) {
            writer.uint32(74).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stopped = reader.bool();
                    break;
                case 3:
                    message.feePoolFeeRatio = reader.string();
                    break;
                case 4:
                    message.ecosystemFundFeeRatio = reader.string();
                    break;
                case 5:
                    message.liquidationFeeRatio = reader.string();
                    break;
                case 6:
                    message.partialLiquidationRatio = reader.string();
                    break;
                case 7:
                    message.fundingRateInterval = reader.string();
                    break;
                case 8:
                    message.twapLookbackWindow = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.whitelistedLiquidators.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            stopped: isSet(object.stopped) ? Boolean(object.stopped) : false,
            feePoolFeeRatio: isSet(object.feePoolFeeRatio)
                ? String(object.feePoolFeeRatio)
                : "",
            ecosystemFundFeeRatio: isSet(object.ecosystemFundFeeRatio)
                ? String(object.ecosystemFundFeeRatio)
                : "",
            liquidationFeeRatio: isSet(object.liquidationFeeRatio)
                ? String(object.liquidationFeeRatio)
                : "",
            partialLiquidationRatio: isSet(object.partialLiquidationRatio)
                ? String(object.partialLiquidationRatio)
                : "",
            fundingRateInterval: isSet(object.fundingRateInterval)
                ? String(object.fundingRateInterval)
                : "",
            twapLookbackWindow: isSet(object.twapLookbackWindow)
                ? duration_1.Duration.fromJSON(object.twapLookbackWindow)
                : undefined,
            whitelistedLiquidators: Array.isArray(object === null || object === void 0 ? void 0 : object.whitelistedLiquidators)
                ? object.whitelistedLiquidators.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.stopped !== undefined && (obj.stopped = message.stopped);
        message.feePoolFeeRatio !== undefined &&
            (obj.feePoolFeeRatio = message.feePoolFeeRatio);
        message.ecosystemFundFeeRatio !== undefined &&
            (obj.ecosystemFundFeeRatio = message.ecosystemFundFeeRatio);
        message.liquidationFeeRatio !== undefined &&
            (obj.liquidationFeeRatio = message.liquidationFeeRatio);
        message.partialLiquidationRatio !== undefined &&
            (obj.partialLiquidationRatio = message.partialLiquidationRatio);
        message.fundingRateInterval !== undefined &&
            (obj.fundingRateInterval = message.fundingRateInterval);
        message.twapLookbackWindow !== undefined &&
            (obj.twapLookbackWindow = message.twapLookbackWindow
                ? duration_1.Duration.toJSON(message.twapLookbackWindow)
                : undefined);
        if (message.whitelistedLiquidators) {
            obj.whitelistedLiquidators = message.whitelistedLiquidators.map((e) => e);
        }
        else {
            obj.whitelistedLiquidators = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseParams();
        message.stopped = (_a = object.stopped) !== null && _a !== void 0 ? _a : false;
        message.feePoolFeeRatio = (_b = object.feePoolFeeRatio) !== null && _b !== void 0 ? _b : "";
        message.ecosystemFundFeeRatio = (_c = object.ecosystemFundFeeRatio) !== null && _c !== void 0 ? _c : "";
        message.liquidationFeeRatio = (_d = object.liquidationFeeRatio) !== null && _d !== void 0 ? _d : "";
        message.partialLiquidationRatio = (_e = object.partialLiquidationRatio) !== null && _e !== void 0 ? _e : "";
        message.fundingRateInterval = (_f = object.fundingRateInterval) !== null && _f !== void 0 ? _f : "";
        message.twapLookbackWindow =
            object.twapLookbackWindow !== undefined && object.twapLookbackWindow !== null
                ? duration_1.Duration.fromPartial(object.twapLookbackWindow)
                : undefined;
        message.whitelistedLiquidators = ((_g = object.whitelistedLiquidators) === null || _g === void 0 ? void 0 : _g.map((e) => e)) || [];
        return message;
    },
};
function createBasePosition() {
    return {
        traderAddress: "",
        pair: "",
        size: "",
        margin: "",
        openNotional: "",
        latestCumulativePremiumFraction: "",
        blockNumber: long_1.default.ZERO,
    };
}
exports.Position = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.traderAddress !== "") {
            writer.uint32(10).string(message.traderAddress);
        }
        if (message.pair !== "") {
            writer.uint32(18).string(message.pair);
        }
        if (message.size !== "") {
            writer.uint32(26).string(message.size);
        }
        if (message.margin !== "") {
            writer.uint32(34).string(message.margin);
        }
        if (message.openNotional !== "") {
            writer.uint32(42).string(message.openNotional);
        }
        if (message.latestCumulativePremiumFraction !== "") {
            writer.uint32(50).string(message.latestCumulativePremiumFraction);
        }
        if (!message.blockNumber.isZero()) {
            writer.uint32(56).int64(message.blockNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePosition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.traderAddress = reader.string();
                    break;
                case 2:
                    message.pair = reader.string();
                    break;
                case 3:
                    message.size = reader.string();
                    break;
                case 4:
                    message.margin = reader.string();
                    break;
                case 5:
                    message.openNotional = reader.string();
                    break;
                case 6:
                    message.latestCumulativePremiumFraction = reader.string();
                    break;
                case 7:
                    message.blockNumber = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            traderAddress: isSet(object.traderAddress) ? String(object.traderAddress) : "",
            pair: isSet(object.pair) ? String(object.pair) : "",
            size: isSet(object.size) ? String(object.size) : "",
            margin: isSet(object.margin) ? String(object.margin) : "",
            openNotional: isSet(object.openNotional) ? String(object.openNotional) : "",
            latestCumulativePremiumFraction: isSet(object.latestCumulativePremiumFraction)
                ? String(object.latestCumulativePremiumFraction)
                : "",
            blockNumber: isSet(object.blockNumber)
                ? long_1.default.fromValue(object.blockNumber)
                : long_1.default.ZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.traderAddress !== undefined && (obj.traderAddress = message.traderAddress);
        message.pair !== undefined && (obj.pair = message.pair);
        message.size !== undefined && (obj.size = message.size);
        message.margin !== undefined && (obj.margin = message.margin);
        message.openNotional !== undefined && (obj.openNotional = message.openNotional);
        message.latestCumulativePremiumFraction !== undefined &&
            (obj.latestCumulativePremiumFraction = message.latestCumulativePremiumFraction);
        message.blockNumber !== undefined &&
            (obj.blockNumber = (message.blockNumber || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBasePosition();
        message.traderAddress = (_a = object.traderAddress) !== null && _a !== void 0 ? _a : "";
        message.pair = (_b = object.pair) !== null && _b !== void 0 ? _b : "";
        message.size = (_c = object.size) !== null && _c !== void 0 ? _c : "";
        message.margin = (_d = object.margin) !== null && _d !== void 0 ? _d : "";
        message.openNotional = (_e = object.openNotional) !== null && _e !== void 0 ? _e : "";
        message.latestCumulativePremiumFraction =
            (_f = object.latestCumulativePremiumFraction) !== null && _f !== void 0 ? _f : "";
        message.blockNumber =
            object.blockNumber !== undefined && object.blockNumber !== null
                ? long_1.default.fromValue(object.blockNumber)
                : long_1.default.ZERO;
        return message;
    },
};
function createBasePairMetadata() {
    return { pair: "", latestCumulativePremiumFraction: "" };
}
exports.PairMetadata = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.latestCumulativePremiumFraction !== "") {
            writer.uint32(18).string(message.latestCumulativePremiumFraction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePairMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.latestCumulativePremiumFraction = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            latestCumulativePremiumFraction: isSet(object.latestCumulativePremiumFraction)
                ? String(object.latestCumulativePremiumFraction)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.latestCumulativePremiumFraction !== undefined &&
            (obj.latestCumulativePremiumFraction = message.latestCumulativePremiumFraction);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePairMetadata();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.latestCumulativePremiumFraction =
            (_b = object.latestCumulativePremiumFraction) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBasePrepaidBadDebt() {
    return { denom: "", amount: "" };
}
exports.PrepaidBadDebt = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrepaidBadDebt();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? String(object.denom) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePrepaidBadDebt();
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBasePositionResp() {
    return {
        position: undefined,
        exchangedNotionalValue: "",
        exchangedPositionSize: "",
        badDebt: "",
        fundingPayment: "",
        realizedPnl: "",
        unrealizedPnlAfter: "",
        marginToVault: "",
        positionNotional: "",
    };
}
exports.PositionResp = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.position !== undefined) {
            exports.Position.encode(message.position, writer.uint32(10).fork()).ldelim();
        }
        if (message.exchangedNotionalValue !== "") {
            writer.uint32(18).string(message.exchangedNotionalValue);
        }
        if (message.exchangedPositionSize !== "") {
            writer.uint32(26).string(message.exchangedPositionSize);
        }
        if (message.badDebt !== "") {
            writer.uint32(34).string(message.badDebt);
        }
        if (message.fundingPayment !== "") {
            writer.uint32(42).string(message.fundingPayment);
        }
        if (message.realizedPnl !== "") {
            writer.uint32(50).string(message.realizedPnl);
        }
        if (message.unrealizedPnlAfter !== "") {
            writer.uint32(58).string(message.unrealizedPnlAfter);
        }
        if (message.marginToVault !== "") {
            writer.uint32(66).string(message.marginToVault);
        }
        if (message.positionNotional !== "") {
            writer.uint32(74).string(message.positionNotional);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionResp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.position = exports.Position.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.exchangedNotionalValue = reader.string();
                    break;
                case 3:
                    message.exchangedPositionSize = reader.string();
                    break;
                case 4:
                    message.badDebt = reader.string();
                    break;
                case 5:
                    message.fundingPayment = reader.string();
                    break;
                case 6:
                    message.realizedPnl = reader.string();
                    break;
                case 7:
                    message.unrealizedPnlAfter = reader.string();
                    break;
                case 8:
                    message.marginToVault = reader.string();
                    break;
                case 9:
                    message.positionNotional = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            position: isSet(object.position) ? exports.Position.fromJSON(object.position) : undefined,
            exchangedNotionalValue: isSet(object.exchangedNotionalValue)
                ? String(object.exchangedNotionalValue)
                : "",
            exchangedPositionSize: isSet(object.exchangedPositionSize)
                ? String(object.exchangedPositionSize)
                : "",
            badDebt: isSet(object.badDebt) ? String(object.badDebt) : "",
            fundingPayment: isSet(object.fundingPayment) ? String(object.fundingPayment) : "",
            realizedPnl: isSet(object.realizedPnl) ? String(object.realizedPnl) : "",
            unrealizedPnlAfter: isSet(object.unrealizedPnlAfter)
                ? String(object.unrealizedPnlAfter)
                : "",
            marginToVault: isSet(object.marginToVault) ? String(object.marginToVault) : "",
            positionNotional: isSet(object.positionNotional)
                ? String(object.positionNotional)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.position !== undefined &&
            (obj.position = message.position ? exports.Position.toJSON(message.position) : undefined);
        message.exchangedNotionalValue !== undefined &&
            (obj.exchangedNotionalValue = message.exchangedNotionalValue);
        message.exchangedPositionSize !== undefined &&
            (obj.exchangedPositionSize = message.exchangedPositionSize);
        message.badDebt !== undefined && (obj.badDebt = message.badDebt);
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.realizedPnl !== undefined && (obj.realizedPnl = message.realizedPnl);
        message.unrealizedPnlAfter !== undefined &&
            (obj.unrealizedPnlAfter = message.unrealizedPnlAfter);
        message.marginToVault !== undefined && (obj.marginToVault = message.marginToVault);
        message.positionNotional !== undefined &&
            (obj.positionNotional = message.positionNotional);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBasePositionResp();
        message.position =
            object.position !== undefined && object.position !== null
                ? exports.Position.fromPartial(object.position)
                : undefined;
        message.exchangedNotionalValue = (_a = object.exchangedNotionalValue) !== null && _a !== void 0 ? _a : "";
        message.exchangedPositionSize = (_b = object.exchangedPositionSize) !== null && _b !== void 0 ? _b : "";
        message.badDebt = (_c = object.badDebt) !== null && _c !== void 0 ? _c : "";
        message.fundingPayment = (_d = object.fundingPayment) !== null && _d !== void 0 ? _d : "";
        message.realizedPnl = (_e = object.realizedPnl) !== null && _e !== void 0 ? _e : "";
        message.unrealizedPnlAfter = (_f = object.unrealizedPnlAfter) !== null && _f !== void 0 ? _f : "";
        message.marginToVault = (_g = object.marginToVault) !== null && _g !== void 0 ? _g : "";
        message.positionNotional = (_h = object.positionNotional) !== null && _h !== void 0 ? _h : "";
        return message;
    },
};
function createBaseLiquidateResp() {
    return {
        badDebt: "",
        feeToLiquidator: "",
        feeToPerpEcosystemFund: "",
        liquidator: "",
        positionResp: undefined,
    };
}
exports.LiquidateResp = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.badDebt !== "") {
            writer.uint32(10).string(message.badDebt);
        }
        if (message.feeToLiquidator !== "") {
            writer.uint32(18).string(message.feeToLiquidator);
        }
        if (message.feeToPerpEcosystemFund !== "") {
            writer.uint32(26).string(message.feeToPerpEcosystemFund);
        }
        if (message.liquidator !== "") {
            writer.uint32(34).string(message.liquidator);
        }
        if (message.positionResp !== undefined) {
            exports.PositionResp.encode(message.positionResp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidateResp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.badDebt = reader.string();
                    break;
                case 2:
                    message.feeToLiquidator = reader.string();
                    break;
                case 3:
                    message.feeToPerpEcosystemFund = reader.string();
                    break;
                case 4:
                    message.liquidator = reader.string();
                    break;
                case 5:
                    message.positionResp = exports.PositionResp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            badDebt: isSet(object.badDebt) ? String(object.badDebt) : "",
            feeToLiquidator: isSet(object.feeToLiquidator)
                ? String(object.feeToLiquidator)
                : "",
            feeToPerpEcosystemFund: isSet(object.feeToPerpEcosystemFund)
                ? String(object.feeToPerpEcosystemFund)
                : "",
            liquidator: isSet(object.liquidator) ? String(object.liquidator) : "",
            positionResp: isSet(object.positionResp)
                ? exports.PositionResp.fromJSON(object.positionResp)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.badDebt !== undefined && (obj.badDebt = message.badDebt);
        message.feeToLiquidator !== undefined &&
            (obj.feeToLiquidator = message.feeToLiquidator);
        message.feeToPerpEcosystemFund !== undefined &&
            (obj.feeToPerpEcosystemFund = message.feeToPerpEcosystemFund);
        message.liquidator !== undefined && (obj.liquidator = message.liquidator);
        message.positionResp !== undefined &&
            (obj.positionResp = message.positionResp
                ? exports.PositionResp.toJSON(message.positionResp)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseLiquidateResp();
        message.badDebt = (_a = object.badDebt) !== null && _a !== void 0 ? _a : "";
        message.feeToLiquidator = (_b = object.feeToLiquidator) !== null && _b !== void 0 ? _b : "";
        message.feeToPerpEcosystemFund = (_c = object.feeToPerpEcosystemFund) !== null && _c !== void 0 ? _c : "";
        message.liquidator = (_d = object.liquidator) !== null && _d !== void 0 ? _d : "";
        message.positionResp =
            object.positionResp !== undefined && object.positionResp !== null
                ? exports.PositionResp.fromPartial(object.positionResp)
                : undefined;
        return message;
    },
};
function createBaseMetrics() {
    return { pair: "", netSize: "", volumeQuote: "", volumeBase: "" };
}
exports.Metrics = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.netSize !== "") {
            writer.uint32(18).string(message.netSize);
        }
        if (message.volumeQuote !== "") {
            writer.uint32(26).string(message.volumeQuote);
        }
        if (message.volumeBase !== "") {
            writer.uint32(34).string(message.volumeBase);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMetrics();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.netSize = reader.string();
                    break;
                case 3:
                    message.volumeQuote = reader.string();
                    break;
                case 4:
                    message.volumeBase = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            netSize: isSet(object.netSize) ? String(object.netSize) : "",
            volumeQuote: isSet(object.volumeQuote) ? String(object.volumeQuote) : "",
            volumeBase: isSet(object.volumeBase) ? String(object.volumeBase) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.netSize !== undefined && (obj.netSize = message.netSize);
        message.volumeQuote !== undefined && (obj.volumeQuote = message.volumeQuote);
        message.volumeBase !== undefined && (obj.volumeBase = message.volumeBase);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMetrics();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.netSize = (_b = object.netSize) !== null && _b !== void 0 ? _b : "";
        message.volumeQuote = (_c = object.volumeQuote) !== null && _c !== void 0 ? _c : "";
        message.volumeBase = (_d = object.volumeBase) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=state.js.map