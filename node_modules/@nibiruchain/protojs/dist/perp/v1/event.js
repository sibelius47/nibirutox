"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsEvent = exports.LiquidationFailedEvent = exports.FundingRateChangedEvent = exports.PositionSettledEvent = exports.PositionLiquidatedEvent = exports.PositionChangedEvent = exports.liquidationFailedEvent_LiquidationFailedReasonToJSON = exports.liquidationFailedEvent_LiquidationFailedReasonFromJSON = exports.LiquidationFailedEvent_LiquidationFailedReason = exports.protobufPackage = void 0;
/* eslint-disable */
const coin_1 = require("../../cosmos/base/v1beta1/coin");
const long_1 = __importDefault(require("long"));
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = "nibiru.perp.v1";
var LiquidationFailedEvent_LiquidationFailedReason;
(function (LiquidationFailedEvent_LiquidationFailedReason) {
    LiquidationFailedEvent_LiquidationFailedReason[LiquidationFailedEvent_LiquidationFailedReason["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /** POSITION_HEALTHY - the position is healthy and does not need to be liquidated. */
    LiquidationFailedEvent_LiquidationFailedReason[LiquidationFailedEvent_LiquidationFailedReason["POSITION_HEALTHY"] = 1] = "POSITION_HEALTHY";
    /** NONEXISTENT_PAIR - the pair does not exist. */
    LiquidationFailedEvent_LiquidationFailedReason[LiquidationFailedEvent_LiquidationFailedReason["NONEXISTENT_PAIR"] = 2] = "NONEXISTENT_PAIR";
    /** NONEXISTENT_POSITION - the position does not exist. */
    LiquidationFailedEvent_LiquidationFailedReason[LiquidationFailedEvent_LiquidationFailedReason["NONEXISTENT_POSITION"] = 3] = "NONEXISTENT_POSITION";
    LiquidationFailedEvent_LiquidationFailedReason[LiquidationFailedEvent_LiquidationFailedReason["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LiquidationFailedEvent_LiquidationFailedReason = exports.LiquidationFailedEvent_LiquidationFailedReason || (exports.LiquidationFailedEvent_LiquidationFailedReason = {}));
function liquidationFailedEvent_LiquidationFailedReasonFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSPECIFIED":
            return LiquidationFailedEvent_LiquidationFailedReason.UNSPECIFIED;
        case 1:
        case "POSITION_HEALTHY":
            return LiquidationFailedEvent_LiquidationFailedReason.POSITION_HEALTHY;
        case 2:
        case "NONEXISTENT_PAIR":
            return LiquidationFailedEvent_LiquidationFailedReason.NONEXISTENT_PAIR;
        case 3:
        case "NONEXISTENT_POSITION":
            return LiquidationFailedEvent_LiquidationFailedReason.NONEXISTENT_POSITION;
        case -1:
        case "UNRECOGNIZED":
        default:
            return LiquidationFailedEvent_LiquidationFailedReason.UNRECOGNIZED;
    }
}
exports.liquidationFailedEvent_LiquidationFailedReasonFromJSON = liquidationFailedEvent_LiquidationFailedReasonFromJSON;
function liquidationFailedEvent_LiquidationFailedReasonToJSON(object) {
    switch (object) {
        case LiquidationFailedEvent_LiquidationFailedReason.UNSPECIFIED:
            return "UNSPECIFIED";
        case LiquidationFailedEvent_LiquidationFailedReason.POSITION_HEALTHY:
            return "POSITION_HEALTHY";
        case LiquidationFailedEvent_LiquidationFailedReason.NONEXISTENT_PAIR:
            return "NONEXISTENT_PAIR";
        case LiquidationFailedEvent_LiquidationFailedReason.NONEXISTENT_POSITION:
            return "NONEXISTENT_POSITION";
        case LiquidationFailedEvent_LiquidationFailedReason.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.liquidationFailedEvent_LiquidationFailedReasonToJSON = liquidationFailedEvent_LiquidationFailedReasonToJSON;
function createBasePositionChangedEvent() {
    return {
        pair: "",
        traderAddress: "",
        margin: undefined,
        positionNotional: "",
        exchangedSize: "",
        exchangedNotional: "",
        transactionFee: undefined,
        positionSize: "",
        realizedPnl: "",
        unrealizedPnlAfter: "",
        badDebt: undefined,
        markPrice: "",
        fundingPayment: "",
        blockHeight: long_1.default.ZERO,
        blockTimeMs: long_1.default.ZERO,
    };
}
exports.PositionChangedEvent = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.traderAddress !== "") {
            writer.uint32(18).string(message.traderAddress);
        }
        if (message.margin !== undefined) {
            coin_1.Coin.encode(message.margin, writer.uint32(26).fork()).ldelim();
        }
        if (message.positionNotional !== "") {
            writer.uint32(34).string(message.positionNotional);
        }
        if (message.exchangedSize !== "") {
            writer.uint32(42).string(message.exchangedSize);
        }
        if (message.exchangedNotional !== "") {
            writer.uint32(50).string(message.exchangedNotional);
        }
        if (message.transactionFee !== undefined) {
            coin_1.Coin.encode(message.transactionFee, writer.uint32(58).fork()).ldelim();
        }
        if (message.positionSize !== "") {
            writer.uint32(66).string(message.positionSize);
        }
        if (message.realizedPnl !== "") {
            writer.uint32(74).string(message.realizedPnl);
        }
        if (message.unrealizedPnlAfter !== "") {
            writer.uint32(82).string(message.unrealizedPnlAfter);
        }
        if (message.badDebt !== undefined) {
            coin_1.Coin.encode(message.badDebt, writer.uint32(90).fork()).ldelim();
        }
        if (message.markPrice !== "") {
            writer.uint32(98).string(message.markPrice);
        }
        if (message.fundingPayment !== "") {
            writer.uint32(106).string(message.fundingPayment);
        }
        if (!message.blockHeight.isZero()) {
            writer.uint32(112).int64(message.blockHeight);
        }
        if (!message.blockTimeMs.isZero()) {
            writer.uint32(120).int64(message.blockTimeMs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionChangedEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.traderAddress = reader.string();
                    break;
                case 3:
                    message.margin = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.positionNotional = reader.string();
                    break;
                case 5:
                    message.exchangedSize = reader.string();
                    break;
                case 6:
                    message.exchangedNotional = reader.string();
                    break;
                case 7:
                    message.transactionFee = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.positionSize = reader.string();
                    break;
                case 9:
                    message.realizedPnl = reader.string();
                    break;
                case 10:
                    message.unrealizedPnlAfter = reader.string();
                    break;
                case 11:
                    message.badDebt = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.markPrice = reader.string();
                    break;
                case 13:
                    message.fundingPayment = reader.string();
                    break;
                case 14:
                    message.blockHeight = reader.int64();
                    break;
                case 15:
                    message.blockTimeMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            traderAddress: isSet(object.traderAddress) ? String(object.traderAddress) : "",
            margin: isSet(object.margin) ? coin_1.Coin.fromJSON(object.margin) : undefined,
            positionNotional: isSet(object.positionNotional)
                ? String(object.positionNotional)
                : "",
            exchangedSize: isSet(object.exchangedSize) ? String(object.exchangedSize) : "",
            exchangedNotional: isSet(object.exchangedNotional)
                ? String(object.exchangedNotional)
                : "",
            transactionFee: isSet(object.transactionFee)
                ? coin_1.Coin.fromJSON(object.transactionFee)
                : undefined,
            positionSize: isSet(object.positionSize) ? String(object.positionSize) : "",
            realizedPnl: isSet(object.realizedPnl) ? String(object.realizedPnl) : "",
            unrealizedPnlAfter: isSet(object.unrealizedPnlAfter)
                ? String(object.unrealizedPnlAfter)
                : "",
            badDebt: isSet(object.badDebt) ? coin_1.Coin.fromJSON(object.badDebt) : undefined,
            markPrice: isSet(object.markPrice) ? String(object.markPrice) : "",
            fundingPayment: isSet(object.fundingPayment) ? String(object.fundingPayment) : "",
            blockHeight: isSet(object.blockHeight)
                ? long_1.default.fromValue(object.blockHeight)
                : long_1.default.ZERO,
            blockTimeMs: isSet(object.blockTimeMs)
                ? long_1.default.fromValue(object.blockTimeMs)
                : long_1.default.ZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.traderAddress !== undefined && (obj.traderAddress = message.traderAddress);
        message.margin !== undefined &&
            (obj.margin = message.margin ? coin_1.Coin.toJSON(message.margin) : undefined);
        message.positionNotional !== undefined &&
            (obj.positionNotional = message.positionNotional);
        message.exchangedSize !== undefined && (obj.exchangedSize = message.exchangedSize);
        message.exchangedNotional !== undefined &&
            (obj.exchangedNotional = message.exchangedNotional);
        message.transactionFee !== undefined &&
            (obj.transactionFee = message.transactionFee
                ? coin_1.Coin.toJSON(message.transactionFee)
                : undefined);
        message.positionSize !== undefined && (obj.positionSize = message.positionSize);
        message.realizedPnl !== undefined && (obj.realizedPnl = message.realizedPnl);
        message.unrealizedPnlAfter !== undefined &&
            (obj.unrealizedPnlAfter = message.unrealizedPnlAfter);
        message.badDebt !== undefined &&
            (obj.badDebt = message.badDebt ? coin_1.Coin.toJSON(message.badDebt) : undefined);
        message.markPrice !== undefined && (obj.markPrice = message.markPrice);
        message.fundingPayment !== undefined &&
            (obj.fundingPayment = message.fundingPayment);
        message.blockHeight !== undefined &&
            (obj.blockHeight = (message.blockHeight || long_1.default.ZERO).toString());
        message.blockTimeMs !== undefined &&
            (obj.blockTimeMs = (message.blockTimeMs || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBasePositionChangedEvent();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.traderAddress = (_b = object.traderAddress) !== null && _b !== void 0 ? _b : "";
        message.margin =
            object.margin !== undefined && object.margin !== null
                ? coin_1.Coin.fromPartial(object.margin)
                : undefined;
        message.positionNotional = (_c = object.positionNotional) !== null && _c !== void 0 ? _c : "";
        message.exchangedSize = (_d = object.exchangedSize) !== null && _d !== void 0 ? _d : "";
        message.exchangedNotional = (_e = object.exchangedNotional) !== null && _e !== void 0 ? _e : "";
        message.transactionFee =
            object.transactionFee !== undefined && object.transactionFee !== null
                ? coin_1.Coin.fromPartial(object.transactionFee)
                : undefined;
        message.positionSize = (_f = object.positionSize) !== null && _f !== void 0 ? _f : "";
        message.realizedPnl = (_g = object.realizedPnl) !== null && _g !== void 0 ? _g : "";
        message.unrealizedPnlAfter = (_h = object.unrealizedPnlAfter) !== null && _h !== void 0 ? _h : "";
        message.badDebt =
            object.badDebt !== undefined && object.badDebt !== null
                ? coin_1.Coin.fromPartial(object.badDebt)
                : undefined;
        message.markPrice = (_j = object.markPrice) !== null && _j !== void 0 ? _j : "";
        message.fundingPayment = (_k = object.fundingPayment) !== null && _k !== void 0 ? _k : "";
        message.blockHeight =
            object.blockHeight !== undefined && object.blockHeight !== null
                ? long_1.default.fromValue(object.blockHeight)
                : long_1.default.ZERO;
        message.blockTimeMs =
            object.blockTimeMs !== undefined && object.blockTimeMs !== null
                ? long_1.default.fromValue(object.blockTimeMs)
                : long_1.default.ZERO;
        return message;
    },
};
function createBasePositionLiquidatedEvent() {
    return {
        pair: "",
        traderAddress: "",
        exchangedQuoteAmount: "",
        exchangedPositionSize: "",
        liquidatorAddress: "",
        feeToLiquidator: undefined,
        feeToEcosystemFund: undefined,
        badDebt: undefined,
        margin: undefined,
        positionNotional: "",
        positionSize: "",
        unrealizedPnl: "",
        markPrice: "",
        blockHeight: long_1.default.ZERO,
        blockTimeMs: long_1.default.ZERO,
    };
}
exports.PositionLiquidatedEvent = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.traderAddress !== "") {
            writer.uint32(18).string(message.traderAddress);
        }
        if (message.exchangedQuoteAmount !== "") {
            writer.uint32(26).string(message.exchangedQuoteAmount);
        }
        if (message.exchangedPositionSize !== "") {
            writer.uint32(34).string(message.exchangedPositionSize);
        }
        if (message.liquidatorAddress !== "") {
            writer.uint32(42).string(message.liquidatorAddress);
        }
        if (message.feeToLiquidator !== undefined) {
            coin_1.Coin.encode(message.feeToLiquidator, writer.uint32(50).fork()).ldelim();
        }
        if (message.feeToEcosystemFund !== undefined) {
            coin_1.Coin.encode(message.feeToEcosystemFund, writer.uint32(58).fork()).ldelim();
        }
        if (message.badDebt !== undefined) {
            coin_1.Coin.encode(message.badDebt, writer.uint32(66).fork()).ldelim();
        }
        if (message.margin !== undefined) {
            coin_1.Coin.encode(message.margin, writer.uint32(74).fork()).ldelim();
        }
        if (message.positionNotional !== "") {
            writer.uint32(82).string(message.positionNotional);
        }
        if (message.positionSize !== "") {
            writer.uint32(90).string(message.positionSize);
        }
        if (message.unrealizedPnl !== "") {
            writer.uint32(98).string(message.unrealizedPnl);
        }
        if (message.markPrice !== "") {
            writer.uint32(106).string(message.markPrice);
        }
        if (!message.blockHeight.isZero()) {
            writer.uint32(112).int64(message.blockHeight);
        }
        if (!message.blockTimeMs.isZero()) {
            writer.uint32(120).int64(message.blockTimeMs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionLiquidatedEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.traderAddress = reader.string();
                    break;
                case 3:
                    message.exchangedQuoteAmount = reader.string();
                    break;
                case 4:
                    message.exchangedPositionSize = reader.string();
                    break;
                case 5:
                    message.liquidatorAddress = reader.string();
                    break;
                case 6:
                    message.feeToLiquidator = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.feeToEcosystemFund = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.badDebt = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.margin = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.positionNotional = reader.string();
                    break;
                case 11:
                    message.positionSize = reader.string();
                    break;
                case 12:
                    message.unrealizedPnl = reader.string();
                    break;
                case 13:
                    message.markPrice = reader.string();
                    break;
                case 14:
                    message.blockHeight = reader.int64();
                    break;
                case 15:
                    message.blockTimeMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            traderAddress: isSet(object.traderAddress) ? String(object.traderAddress) : "",
            exchangedQuoteAmount: isSet(object.exchangedQuoteAmount)
                ? String(object.exchangedQuoteAmount)
                : "",
            exchangedPositionSize: isSet(object.exchangedPositionSize)
                ? String(object.exchangedPositionSize)
                : "",
            liquidatorAddress: isSet(object.liquidatorAddress)
                ? String(object.liquidatorAddress)
                : "",
            feeToLiquidator: isSet(object.feeToLiquidator)
                ? coin_1.Coin.fromJSON(object.feeToLiquidator)
                : undefined,
            feeToEcosystemFund: isSet(object.feeToEcosystemFund)
                ? coin_1.Coin.fromJSON(object.feeToEcosystemFund)
                : undefined,
            badDebt: isSet(object.badDebt) ? coin_1.Coin.fromJSON(object.badDebt) : undefined,
            margin: isSet(object.margin) ? coin_1.Coin.fromJSON(object.margin) : undefined,
            positionNotional: isSet(object.positionNotional)
                ? String(object.positionNotional)
                : "",
            positionSize: isSet(object.positionSize) ? String(object.positionSize) : "",
            unrealizedPnl: isSet(object.unrealizedPnl) ? String(object.unrealizedPnl) : "",
            markPrice: isSet(object.markPrice) ? String(object.markPrice) : "",
            blockHeight: isSet(object.blockHeight)
                ? long_1.default.fromValue(object.blockHeight)
                : long_1.default.ZERO,
            blockTimeMs: isSet(object.blockTimeMs)
                ? long_1.default.fromValue(object.blockTimeMs)
                : long_1.default.ZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.traderAddress !== undefined && (obj.traderAddress = message.traderAddress);
        message.exchangedQuoteAmount !== undefined &&
            (obj.exchangedQuoteAmount = message.exchangedQuoteAmount);
        message.exchangedPositionSize !== undefined &&
            (obj.exchangedPositionSize = message.exchangedPositionSize);
        message.liquidatorAddress !== undefined &&
            (obj.liquidatorAddress = message.liquidatorAddress);
        message.feeToLiquidator !== undefined &&
            (obj.feeToLiquidator = message.feeToLiquidator
                ? coin_1.Coin.toJSON(message.feeToLiquidator)
                : undefined);
        message.feeToEcosystemFund !== undefined &&
            (obj.feeToEcosystemFund = message.feeToEcosystemFund
                ? coin_1.Coin.toJSON(message.feeToEcosystemFund)
                : undefined);
        message.badDebt !== undefined &&
            (obj.badDebt = message.badDebt ? coin_1.Coin.toJSON(message.badDebt) : undefined);
        message.margin !== undefined &&
            (obj.margin = message.margin ? coin_1.Coin.toJSON(message.margin) : undefined);
        message.positionNotional !== undefined &&
            (obj.positionNotional = message.positionNotional);
        message.positionSize !== undefined && (obj.positionSize = message.positionSize);
        message.unrealizedPnl !== undefined && (obj.unrealizedPnl = message.unrealizedPnl);
        message.markPrice !== undefined && (obj.markPrice = message.markPrice);
        message.blockHeight !== undefined &&
            (obj.blockHeight = (message.blockHeight || long_1.default.ZERO).toString());
        message.blockTimeMs !== undefined &&
            (obj.blockTimeMs = (message.blockTimeMs || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBasePositionLiquidatedEvent();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.traderAddress = (_b = object.traderAddress) !== null && _b !== void 0 ? _b : "";
        message.exchangedQuoteAmount = (_c = object.exchangedQuoteAmount) !== null && _c !== void 0 ? _c : "";
        message.exchangedPositionSize = (_d = object.exchangedPositionSize) !== null && _d !== void 0 ? _d : "";
        message.liquidatorAddress = (_e = object.liquidatorAddress) !== null && _e !== void 0 ? _e : "";
        message.feeToLiquidator =
            object.feeToLiquidator !== undefined && object.feeToLiquidator !== null
                ? coin_1.Coin.fromPartial(object.feeToLiquidator)
                : undefined;
        message.feeToEcosystemFund =
            object.feeToEcosystemFund !== undefined && object.feeToEcosystemFund !== null
                ? coin_1.Coin.fromPartial(object.feeToEcosystemFund)
                : undefined;
        message.badDebt =
            object.badDebt !== undefined && object.badDebt !== null
                ? coin_1.Coin.fromPartial(object.badDebt)
                : undefined;
        message.margin =
            object.margin !== undefined && object.margin !== null
                ? coin_1.Coin.fromPartial(object.margin)
                : undefined;
        message.positionNotional = (_f = object.positionNotional) !== null && _f !== void 0 ? _f : "";
        message.positionSize = (_g = object.positionSize) !== null && _g !== void 0 ? _g : "";
        message.unrealizedPnl = (_h = object.unrealizedPnl) !== null && _h !== void 0 ? _h : "";
        message.markPrice = (_j = object.markPrice) !== null && _j !== void 0 ? _j : "";
        message.blockHeight =
            object.blockHeight !== undefined && object.blockHeight !== null
                ? long_1.default.fromValue(object.blockHeight)
                : long_1.default.ZERO;
        message.blockTimeMs =
            object.blockTimeMs !== undefined && object.blockTimeMs !== null
                ? long_1.default.fromValue(object.blockTimeMs)
                : long_1.default.ZERO;
        return message;
    },
};
function createBasePositionSettledEvent() {
    return { pair: "", traderAddress: "", settledCoins: [] };
}
exports.PositionSettledEvent = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.traderAddress !== "") {
            writer.uint32(18).string(message.traderAddress);
        }
        for (const v of message.settledCoins) {
            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePositionSettledEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.traderAddress = reader.string();
                    break;
                case 3:
                    message.settledCoins.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            traderAddress: isSet(object.traderAddress) ? String(object.traderAddress) : "",
            settledCoins: Array.isArray(object === null || object === void 0 ? void 0 : object.settledCoins)
                ? object.settledCoins.map((e) => coin_1.Coin.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.traderAddress !== undefined && (obj.traderAddress = message.traderAddress);
        if (message.settledCoins) {
            obj.settledCoins = message.settledCoins.map((e) => e ? coin_1.Coin.toJSON(e) : undefined);
        }
        else {
            obj.settledCoins = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePositionSettledEvent();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.traderAddress = (_b = object.traderAddress) !== null && _b !== void 0 ? _b : "";
        message.settledCoins = ((_c = object.settledCoins) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
    },
};
function createBaseFundingRateChangedEvent() {
    return {
        pair: "",
        markPrice: "",
        indexPrice: "",
        latestFundingRate: "",
        latestPremiumFraction: "",
        cumulativePremiumFraction: "",
        blockHeight: long_1.default.ZERO,
        blockTimeMs: long_1.default.ZERO,
    };
}
exports.FundingRateChangedEvent = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.markPrice !== "") {
            writer.uint32(18).string(message.markPrice);
        }
        if (message.indexPrice !== "") {
            writer.uint32(26).string(message.indexPrice);
        }
        if (message.latestFundingRate !== "") {
            writer.uint32(34).string(message.latestFundingRate);
        }
        if (message.latestPremiumFraction !== "") {
            writer.uint32(42).string(message.latestPremiumFraction);
        }
        if (message.cumulativePremiumFraction !== "") {
            writer.uint32(50).string(message.cumulativePremiumFraction);
        }
        if (!message.blockHeight.isZero()) {
            writer.uint32(56).int64(message.blockHeight);
        }
        if (!message.blockTimeMs.isZero()) {
            writer.uint32(64).int64(message.blockTimeMs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFundingRateChangedEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.markPrice = reader.string();
                    break;
                case 3:
                    message.indexPrice = reader.string();
                    break;
                case 4:
                    message.latestFundingRate = reader.string();
                    break;
                case 5:
                    message.latestPremiumFraction = reader.string();
                    break;
                case 6:
                    message.cumulativePremiumFraction = reader.string();
                    break;
                case 7:
                    message.blockHeight = reader.int64();
                    break;
                case 8:
                    message.blockTimeMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            markPrice: isSet(object.markPrice) ? String(object.markPrice) : "",
            indexPrice: isSet(object.indexPrice) ? String(object.indexPrice) : "",
            latestFundingRate: isSet(object.latestFundingRate)
                ? String(object.latestFundingRate)
                : "",
            latestPremiumFraction: isSet(object.latestPremiumFraction)
                ? String(object.latestPremiumFraction)
                : "",
            cumulativePremiumFraction: isSet(object.cumulativePremiumFraction)
                ? String(object.cumulativePremiumFraction)
                : "",
            blockHeight: isSet(object.blockHeight)
                ? long_1.default.fromValue(object.blockHeight)
                : long_1.default.ZERO,
            blockTimeMs: isSet(object.blockTimeMs)
                ? long_1.default.fromValue(object.blockTimeMs)
                : long_1.default.ZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.markPrice !== undefined && (obj.markPrice = message.markPrice);
        message.indexPrice !== undefined && (obj.indexPrice = message.indexPrice);
        message.latestFundingRate !== undefined &&
            (obj.latestFundingRate = message.latestFundingRate);
        message.latestPremiumFraction !== undefined &&
            (obj.latestPremiumFraction = message.latestPremiumFraction);
        message.cumulativePremiumFraction !== undefined &&
            (obj.cumulativePremiumFraction = message.cumulativePremiumFraction);
        message.blockHeight !== undefined &&
            (obj.blockHeight = (message.blockHeight || long_1.default.ZERO).toString());
        message.blockTimeMs !== undefined &&
            (obj.blockTimeMs = (message.blockTimeMs || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseFundingRateChangedEvent();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.markPrice = (_b = object.markPrice) !== null && _b !== void 0 ? _b : "";
        message.indexPrice = (_c = object.indexPrice) !== null && _c !== void 0 ? _c : "";
        message.latestFundingRate = (_d = object.latestFundingRate) !== null && _d !== void 0 ? _d : "";
        message.latestPremiumFraction = (_e = object.latestPremiumFraction) !== null && _e !== void 0 ? _e : "";
        message.cumulativePremiumFraction = (_f = object.cumulativePremiumFraction) !== null && _f !== void 0 ? _f : "";
        message.blockHeight =
            object.blockHeight !== undefined && object.blockHeight !== null
                ? long_1.default.fromValue(object.blockHeight)
                : long_1.default.ZERO;
        message.blockTimeMs =
            object.blockTimeMs !== undefined && object.blockTimeMs !== null
                ? long_1.default.fromValue(object.blockTimeMs)
                : long_1.default.ZERO;
        return message;
    },
};
function createBaseLiquidationFailedEvent() {
    return { pair: "", trader: "", liquidator: "", reason: 0 };
}
exports.LiquidationFailedEvent = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.trader !== "") {
            writer.uint32(18).string(message.trader);
        }
        if (message.liquidator !== "") {
            writer.uint32(26).string(message.liquidator);
        }
        if (message.reason !== 0) {
            writer.uint32(32).int32(message.reason);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLiquidationFailedEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.trader = reader.string();
                    break;
                case 3:
                    message.liquidator = reader.string();
                    break;
                case 4:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            trader: isSet(object.trader) ? String(object.trader) : "",
            liquidator: isSet(object.liquidator) ? String(object.liquidator) : "",
            reason: isSet(object.reason)
                ? liquidationFailedEvent_LiquidationFailedReasonFromJSON(object.reason)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.trader !== undefined && (obj.trader = message.trader);
        message.liquidator !== undefined && (obj.liquidator = message.liquidator);
        message.reason !== undefined &&
            (obj.reason = liquidationFailedEvent_LiquidationFailedReasonToJSON(message.reason));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseLiquidationFailedEvent();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.trader = (_b = object.trader) !== null && _b !== void 0 ? _b : "";
        message.liquidator = (_c = object.liquidator) !== null && _c !== void 0 ? _c : "";
        message.reason = (_d = object.reason) !== null && _d !== void 0 ? _d : 0;
        return message;
    },
};
function createBaseMetricsEvent() {
    return {
        pair: "",
        netSize: "",
        volumeQuote: "",
        volumeBase: "",
        blockHeight: long_1.default.ZERO,
        blockTimeMs: long_1.default.ZERO,
    };
}
exports.MetricsEvent = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pair !== "") {
            writer.uint32(10).string(message.pair);
        }
        if (message.netSize !== "") {
            writer.uint32(18).string(message.netSize);
        }
        if (message.volumeQuote !== "") {
            writer.uint32(26).string(message.volumeQuote);
        }
        if (message.volumeBase !== "") {
            writer.uint32(34).string(message.volumeBase);
        }
        if (!message.blockHeight.isZero()) {
            writer.uint32(40).int64(message.blockHeight);
        }
        if (!message.blockTimeMs.isZero()) {
            writer.uint32(48).int64(message.blockTimeMs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMetricsEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pair = reader.string();
                    break;
                case 2:
                    message.netSize = reader.string();
                    break;
                case 3:
                    message.volumeQuote = reader.string();
                    break;
                case 4:
                    message.volumeBase = reader.string();
                    break;
                case 5:
                    message.blockHeight = reader.int64();
                    break;
                case 6:
                    message.blockTimeMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pair: isSet(object.pair) ? String(object.pair) : "",
            netSize: isSet(object.netSize) ? String(object.netSize) : "",
            volumeQuote: isSet(object.volumeQuote) ? String(object.volumeQuote) : "",
            volumeBase: isSet(object.volumeBase) ? String(object.volumeBase) : "",
            blockHeight: isSet(object.blockHeight)
                ? long_1.default.fromValue(object.blockHeight)
                : long_1.default.ZERO,
            blockTimeMs: isSet(object.blockTimeMs)
                ? long_1.default.fromValue(object.blockTimeMs)
                : long_1.default.ZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pair !== undefined && (obj.pair = message.pair);
        message.netSize !== undefined && (obj.netSize = message.netSize);
        message.volumeQuote !== undefined && (obj.volumeQuote = message.volumeQuote);
        message.volumeBase !== undefined && (obj.volumeBase = message.volumeBase);
        message.blockHeight !== undefined &&
            (obj.blockHeight = (message.blockHeight || long_1.default.ZERO).toString());
        message.blockTimeMs !== undefined &&
            (obj.blockTimeMs = (message.blockTimeMs || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMetricsEvent();
        message.pair = (_a = object.pair) !== null && _a !== void 0 ? _a : "";
        message.netSize = (_b = object.netSize) !== null && _b !== void 0 ? _b : "";
        message.volumeQuote = (_c = object.volumeQuote) !== null && _c !== void 0 ? _c : "";
        message.volumeBase = (_d = object.volumeBase) !== null && _d !== void 0 ? _d : "";
        message.blockHeight =
            object.blockHeight !== undefined && object.blockHeight !== null
                ? long_1.default.fromValue(object.blockHeight)
                : long_1.default.ZERO;
        message.blockTimeMs =
            object.blockTimeMs !== undefined && object.blockTimeMs !== null
                ? long_1.default.fromValue(object.blockTimeMs)
                : long_1.default.ZERO;
        return message;
    },
};
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=event.js.map