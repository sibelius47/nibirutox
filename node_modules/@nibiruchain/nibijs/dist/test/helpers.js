"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertHasEventType = exports.assertHasMsgType = exports.validateBlock = exports.validateBlockFromJsonRpc = exports.TEST_ADDRESS = exports.TEST_MNEMONIC = exports.TEST_CHAIN = void 0;
const chain_1 = require("../chain");
exports.TEST_CHAIN = chain_1.Localnet;
// export const TEST_CHAIN = new CustomChain({
//   prefix: "nibiru",
//   shortName: "itn",
//   number: 1,
// }) // v0.19.2
exports.TEST_MNEMONIC = (_a = process.env.VALIDATOR_MNEMONIC) !== null && _a !== void 0 ? _a : "guard cream sadness conduct invite crumble clock pudding hole grit liar hotel maid produce squeeze return argue turtle know drive eight casino maze host";
exports.TEST_ADDRESS = (_b = process.env.VALIDATOR_ADDRESS) !== null && _b !== void 0 ? _b : "nibi1zaavvzxez0elundtn32qnk9lkm8kmcsz44g7xl";
function validateBlockFromJsonRpc(blockJson) {
    const blockSchema = {
        header: ["version", "chain_id", "height", "last_block_id"].concat(["last_commit_hash", "data_hash", "validators_hash", "next_validators_hash"], ["consensus_hash", "app_hash", "last_results_hash", "evidence_hash"], ["proposer_address"]),
        data: ["txs"],
        evidence: ["evidence"],
        last_commit: ["height", "round", "block_id", "signatures"],
    };
    for (const attr in blockSchema) {
        expect(blockJson).toHaveProperty(attr);
        const blockSchemaAtAttr = blockSchema[attr];
        for (const subAttr of blockSchemaAtAttr) {
            expect(blockJson[attr]).toHaveProperty(subAttr);
        }
    }
}
exports.validateBlockFromJsonRpc = validateBlockFromJsonRpc;
function validateBlock(block, chain) {
    expect(block.header.chainId).toEqual(chain.chainId);
    expect(block.header.time).toBeDefined();
    expect(block.header.height).toBeGreaterThanOrEqual(1);
    expect(block).toHaveProperty("txs");
}
exports.validateBlock = validateBlock;
function assertHasMsgType(msgType, events) {
    events.forEach((event) => {
        if (event.type === "message") {
            expect(event.attributes).toContainEqual({
                key: "action",
                value: msgType,
            });
        }
    });
}
exports.assertHasMsgType = assertHasMsgType;
function assertHasEventType(eventType, events) {
    const eventTypes = events.map((event) => event.type);
    expect(eventTypes).toContain(eventType);
}
exports.assertHasEventType = assertHasEventType;
//# sourceMappingURL=helpers.js.map