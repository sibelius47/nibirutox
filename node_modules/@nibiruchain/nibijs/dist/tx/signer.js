"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signer = exports.newRandomWallet = exports.newSignerFromKeplr = exports.newSignerFromMnemonic = exports.getRegistry = exports.BECH32_PREFIX = void 0;
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
var BECH32_PREFIX;
(function (BECH32_PREFIX) {
    /** ADDR defines the Bech32 prefix of an account address */
    BECH32_PREFIX["ADDR"] = "nibi";
    /** ADDR_VAL defines the Bech32 prefix of an validator's operator address */
    BECH32_PREFIX["ADDR_VAL"] = "nibivaloper";
    /** ADDR_VALCONS defines the Bech32 prefix of a consensus node address */
    BECH32_PREFIX["ADDR_VALCONS"] = "nibivalcons";
    /** PUB defines the Bech32 prefix of an account's public key */
    BECH32_PREFIX["PUB"] = "nibipub";
    /** PUB_VAL defines the Bech32 prefix of an validator's operator public key */
    BECH32_PREFIX["PUB_VAL"] = "nibivaloperpub";
    /** PUB_VALCONS defines the Bech32 prefix of a consensus node public key */
    BECH32_PREFIX["PUB_VALCONS"] = "nibivalconspub";
})(BECH32_PREFIX = exports.BECH32_PREFIX || (exports.BECH32_PREFIX = {}));
// Q: Why is this constant here?
const DEFAULT_DERIVATION_PATH = "m/44'/118'/0'/0/0";
function getRegistry() {
    return new proto_signing_1.Registry(stargate_1.defaultRegistryTypes);
}
exports.getRegistry = getRegistry;
/**
 * Creates a wallet from the given BIP39 mnemonic.
 *
 * @export
 * @param mnemonic
 * @param prefix - (optional) Bech32 address prefix. Defaults to "nibi".
 * @returns A wallet for protobuf based signing using SIGN_MODE_DIRECT
 */
function newSignerFromMnemonic(mnemonic, prefix = BECH32_PREFIX.ADDR) {
    return __awaiter(this, void 0, void 0, function* () {
        return proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(mnemonic, { prefix });
    });
}
exports.newSignerFromMnemonic = newSignerFromMnemonic;
function newSignerFromKeplr(keplr, chainId) {
    return keplr.getOfflineSigner(chainId);
}
exports.newSignerFromKeplr = newSignerFromKeplr;
/**
 * Generates a new wallet with a BIP39 mnemonic of length 24.
 *
 * @export
 * @param length (optional) The number of words in the mnemonic (12, 15, 18, 21 or 24).
 * @param prefix - (optional) Bech32 address prefix. Defaults to "nibi".
 * @returns A wallet for protobuf based signing using SIGN_MODE_DIRECT.
 */
function newRandomWallet(length, prefix = BECH32_PREFIX.ADDR) {
    return proto_signing_1.DirectSecp256k1HdWallet.generate(length || 24, { prefix });
}
exports.newRandomWallet = newRandomWallet;
var Signer;
(function (Signer) {
    Signer["Keplr"] = "keplr";
    Signer["Direct"] = "direct";
})(Signer = exports.Signer || (exports.Signer = {}));
//# sourceMappingURL=signer.js.map